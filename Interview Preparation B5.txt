' modAutomationHelpers module

Option Explicit ' Forces variable declaration

'****************************************************************************************************
' Declarations for Windows API functions
'****************************************************************************************************

' Used for pausing execution
Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

' Used for finding windows
Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare Function SetForegroundWindow Lib "user32" (ByVal hWnd As Long) As Long
Public Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As Any) As Long

' Used for sending window messages
Public Declare Function SendMessageByString Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As String) As Long
Public Declare Function SendMessageByNum Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Public Declare Function SendMessageInt Lib "user32.dll" Alias "SendMessageA" (ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Public Declare Function SendMessageLong Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Public Declare Function PostMessage Lib "user32" Alias "PostMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

' Used for getting window information
Public Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
Public Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Public Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hWnd As Long) As Long

' Used for keyboard events
Public Declare Function MapVirtualKey Lib "user32" Alias "MapVirtualKeyA" (ByVal wCode As Long, ByVal wMapType As Long) As Long

' Using conditional compilation for 32-bit/64-bit compatibility
#If VBA7 Then
    Public Declare PtrSafe Sub keybd_event Lib "user32.dll" (ByVal bVk As Byte, ByVal bScan As Byte, _
                                                              ByVal dwFlags As LongPtr, ByVal dwExtraInfo As LongPtr)
    Public Declare PtrSafe Function GetKeyboardState Lib "user32.dll" (ByVal lpKeyState As LongPtr) As Boolean
    Public Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
#Else
    Public Declare Sub keybd_event Lib "user32.dll" (ByVal bVk As Byte, ByVal bScan As Byte, _
                                                      ByVal dwFlags As Long, ByVal dwExtraInfo As Long)
    Public Declare Function GetKeyboardState Lib "user32.dll" (ByVal lpKeyState As Long) As Boolean
    Public Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
#End If

' Used for launching external processes
Public Declare Function ShellExecute Lib "Shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long

'****************************************************************************************************
' Constants for Windows API / Key Events
'****************************************************************************************************

Public Const WM_SETTEXT = &HC
Public Const BM_CLICK = &HF5
Public Const VK_RETURN = &HD
Public Const WM_CHAR = &H102
Public Const KEYEVENTF_KEYUP = &H2
Public Const VK_TAB = &H9
Public Const VK_MENU = &H12 ' VK_MENU is Alt
Public Const WM_KEYDOWN = &H100
Public Const WM_KEYUP = &H101
Public Const VK_CONTROL = &H11
Public Const VK_SHIFT = &H10
Public Const VK_BACK = &H8
Public Const VK_LBUTTON = &H1
Public Const WM_SYSKEYDOWN = &H104 ' System key down (e.g., Alt)
Public Const WM_SYSKEYUP = &H105   ' System key up
Public Const WM_LBUTTONDOWN = &H201
Public Const WM_LBUTTONUP = &H202

Public Const ENTER_KEY_CODE = 13

Public Const KEYEVENTF_EXTENDEDKEY As Long = &H1

Public Const VK_NUMLOCK As Byte = &H90
Public Const NUM_LOCK_SCAN_CODE As Byte = &H45


'****************************************************************************************************
' Public Variables for UI Automation Objects and Patterns
' Requires Microsoft UI Automation Client library reference (Tools -> References)
'****************************************************************************************************

' You MUST add a reference to the Microsoft UI Automation library in your VBA project.
' Go to Tools -> References... and check "Microsoft UI Automation Client library".
Public gUIA                                             As New CUIAutomation ' Main UIA object
Public gDesktopElement                                  As IUIAutomationElement ' Desktop root element
Public gApplicationElement                              As IUIAutomationElement ' Typically represents the main application window element
Public gApplicationElement2                             As IUIAutomationElement ' Used as a temporary element variable

Public gFoundElements                                   As IUIAutomationElementArray ' Used to hold collections of found elements
Public gSubElements                                     As IUIAutomationElementArray ' Used to hold collections of found elements (alternative)

' Pattern variables
' Keeping global here for consistency with the original code structure.
' They must be Set Nothing and Set for each element they are used with.
Public gPatternLegacyAccessible                       As UIAutomationClient.IUIAutomationLegacyIAccessiblePattern
Public gPatternValue                                  As UIAutomationClient.IUIAutomationValuePattern
Public gPatternInvoke                                 As UIAutomationClient.IUIAutomationInvokePattern
Public gPatternToggle                                 As UIAutomationClient.IUIAutomationTogglePattern
Public gPatternSelectionItem                          As UIAutomationClient.IUIAutomationSelectionItemPattern
Public gPatternItemContain                            As UIAutomationClient.IUIAutomationItemContainerPattern
Public gPatternExpand                                 As UIAutomationClient.IUIAutomationExpandCollapsePattern
Public gPatternCollapse                               As UIAutomationClient.IUIAutomationExpandCollapsePattern
Public gPatternScroll                                 As UIAutomationClient.IUIAutomationScrollPattern
Public gPatternScrollItem                             As UIAutomationClient.IUIAutomationScrollItemPattern
Public gPatternWindow                                 As UIAutomationClient.IUIAutomationWindowPattern

' Condition variables
' Keeping global here for consistency with the original code structure.
' They must be Set Nothing and Set for each condition created.
Public gCondition1                                    As UIAutomationClient.IUIAutomationCondition
Public gCondition2                                    As UIAutomationClient.IUIAutomationCondition
Public gCondition3                                    As UIAutomationClient.IUIAutomationCondition

'****************************************************************************************************
' Constants for UI Automation Properties and Patterns
'****************************************************************************************************

Public Const PROP_NAME                                  As String = "NAME"
Public Const PROP_CLASSNAME                             As String = "CLASSNAME"
Public Const PROP_AUTOMATIONID                          As String = "AUTOMATIONID"
Public Const PROP_LOCALISEDCONTROLTYPE                  As String = "LOCALISEDCONTROLTYPE"

Public Const PATTERN_LEGACY                             As String = "LEGACY"
Public Const PATTERN_VALUE                              As String = "VALUE"
Public Const PATTERN_SELECTION                          As String = "SELECTION"
Public Const PATTERN_INVOKE                             As String = "INVOKE"
Public Const PATTERN_TOGGLE                             As String = "TOGGLE"
Public Const PATTERN_ITEM_CONTAIN                       As String = "ITEM CONTAIN"
Public Const PATTERN_EXPAND_COLLAPSE                    As String = "EXPAND COLLAPSE"
Public Const PATTERN_SCROLL                             As String = "SCROLL"
Public Const PATTERN_SCROLL_ITEM                        As String = "SCROLL ITEM"

Public Const ACTION_PUTSTRING                           As String = "PUTSTRING"
Public Const ACTION_GETSTRING                           As String = "GETSTRING"
Public Const ELEMENT_TYPE_BUTTON                        As String = "BUTTON"

'****************************************************************************************************
' Helper Functions (Automation Library)
'****************************************************************************************************

Public Function OpenBrowser(ByVal processName As String, ByVal url As String) As Boolean
    ' Opens a new browser window (Edge or Chrome) at a specified URL.
    ' Uses ShellExecute API and reads registry for process path.

    Dim wshShell As Object
    Dim processPath As String
    Dim commandLine As String
    Dim shellResult As Long ' Result from ShellExecute

    OpenBrowser = False ' Initialize return value

    On Error GoTo ErrorHandler

    Set wshShell = CreateObject("WScript.Shell")

    ' Read the default path for the browser executable from the registry
    On Error Resume Next ' Handle case where registry key might not exist
    processPath = wshShell.RegRead("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\" & processName & "\")
    On Error GoTo ErrorHandler ' Resume normal error handling

    Set wshShell = Nothing ' Clean up object

    If processPath <> "" Then
        commandLine = processPath & " /new-window " & url
        shellResult = ShellExecute(0, "open", commandLine, "", "", 1)

        If shellResult > 32 Then
            Application.Wait VBA.DateAdd("s", 1, Now)
            OpenBrowser = True
        Else
            Debug.Print "ShellExecute failed with error code: " & shellResult & ". Could not open browser: " & processName
            MsgBox "Failed to open browser. Check if " & processName & " is installed correctly.", vbCritical
        End If
    Else
        Debug.Print "Could not find registry path for browser process: " & processName
        MsgBox "Could not find installation path for browser: " & processName & vbCritical
    End If

ExitProcedure:
    Exit Function

ErrorHandler:
    OpenBrowser = False
    Debug.Print "Error in OpenBrowser: " & Err.Description & " (Error " & Err.Number & ")"
    If Not wshShell Is Nothing Then Set wshShell = Nothing
    Resume ExitProcedure
End Function


Public Function SendKeyToWindow(ByVal windowTitle As String, ByVal keyString As String, Optional ByVal X As Integer, Optional ByVal Y As Integer) As Boolean
    ' Sends a key press or mouse click to a window by title and class name.
    ' Uses Windows API PostMessage.
    ' Requires various API declarations (FindWindow, PostMessage, etc.) and constants (WM_KEYDOWN, etc.).
    ' Requires MakeDWord and CleanString helper functions.

    Dim windowHandle As Long
    Dim actualWindowTitle As String
    Dim specialKeyCode As Long
    Dim vkCode As Long
    Dim paramL As Long

    SendKeyToWindow = False
    specialKeyCode = 0

    Select Case LCase(keyString)
        Case "control":   specialKeyCode = VK_CONTROL
        Case "shift":     specialKeyCode = VK_SHIFT
        Case "alt":       specialKeyCode = VK_MENU
        Case "mouseclick":specialKeyCode = VK_LBUTTON
        Case "backspace": specialKeyCode = VK_BACK
        Case "tab":       specialKeyCode = VK_TAB
        Case "enter":     specialKeyCode = VK_RETURN
        Case Else:        specialKeyCode = 0
    End Select

    windowHandle = FindWindow("Chrome_WidgetWin_1", vbNullString)

    Do While windowHandle <> 0
        Dim titleLength As Long
        titleLength = GetWindowTextLength(windowHandle)

        If titleLength > 0 Then
            Dim windowTitleBuffer As String * 256
            GetWindowText windowHandle, windowTitleBuffer, 256
            actualWindowTitle = Left(windowTitleBuffer, titleLength)
        Else
            actualWindowTitle = ""
        End If

        If InStr(1, CleanString(VBA.Trim(UCase(actualWindowTitle))), CleanString(VBA.Trim(UCase(windowTitle))), vbTextCompare) > 0 Then

            If specialKeyCode = VK_LBUTTON Then
                If Not IsMissing(X) And Not IsMissing(Y) Then
                    paramL = MakeDWord(CInt(X), CInt(Y))
                    PostMessage windowHandle, WM_LBUTTONDOWN, 1, paramL
                    Sleep 100
                    PostMessage windowHandle, WM_LBUTTONUP, 0, paramL
                    SendKeyToWindow = True
                Else
                    Debug.Print "SendKeyToWindow: X and Y coordinates are required for 'mouseclick'."
                    SendKeyToWindow = False
                End If

            ElseIf specialKeyCode <> 0 Then
                 vkCode = specialKeyCode
                 paramL = 1 + MapVirtualKey(vkCode, 0) * &H10000
                 PostMessage windowHandle, WM_KEYDOWN, vkCode, paramL
                 Sleep 100
                 PostMessage windowHandle, WM_KEYUP, vkCode, paramL
                 SendKeyToWindow = True

            Else
                 vkCode = Asc(keyString)
                 If vkCode = 0 Then vkCode = CStr(keyString)
                 paramL = 1 + MapVirtualKey(vkCode, 0) * &H10000
                 PostMessage windowHandle, WM_KEYDOWN, vkCode, paramL
                 PostMessage windowHandle, WM_KEYDOWN, vkCode, paramL
                 Sleep 100
                 SendKeyToWindow = True

            End If

            Exit Do

        End If

        windowHandle = FindWindowEx(0, windowHandle, "Chrome_WidgetWin_1", vbNullString)

    Loop

    If windowHandle = 0 Then
        Debug.Print "SendKeyToWindow: Window '" & windowTitle & "' with class 'Chrome_WidgetWin_1' not found."
        SendKeyToWindow = False
    End If

End Function

Public Function MakeDWord(ByVal lowWord As Integer, ByVal highWord As Integer) As Long
    ' Helper function to construct a 32-bit Long from two 16-bit Integers.
    MakeDWord = (CLng(highWord) * &H10000) Or (lowWord And &HFFFF&)
End Function

Public Sub PressEnter()
    ' Simulates pressing and releasing the Enter key using keybd_event.
    On Error GoTo ErrorHandler

    keybd_event VK_RETURN, 0, 0, 0&
    keybd_event VK_RETURN, 0, KEYEVENTF_KEYUP, 0&

ExitProcedure:
    Exit Sub

ErrorHandler:
    Debug.Print "Error in PressEnter: " & Err.Description & " (Error " & Err.Number & ")"
    Resume ExitProcedure
End Sub

Public Function CleanString(ByVal inputString As String) As String
    ' Helper function to remove non-alphanumeric characters and replace with spaces.

    Dim cleanedString As String
    Dim char As Variant
    Dim i As Long

    cleanedString = ""

    For i = 1 To Len(inputString)
        char = Mid(inputString, i, 1)
        If (char >= "a" And char <= "z") Or (char >= "0" And char <= "9") Or (char >= "A" And char <= "Z") Then
            cleanedString = cleanedString & char
        Else
            cleanedString = cleanedString & " "
        End If
    Next

    CleanString = cleanedString
End Function


Public Function AttachBrowserUIA(ByVal browserTitle As String, ByVal maxWaitSeconds As Integer, Optional ByVal browserType As String) As IUIAutomationElement
    ' Attaches to an existing browser window using UI Automation.
    ' Requires UIA declarations and Sleep.

    Dim childIndex As Long
    Dim attempts As Long
    Dim isAttached As Boolean

    On Error GoTo ErrorHandler

    isAttached = False
    Set AttachBrowserUIA = Nothing
    Set gDesktopElement = Nothing
    Set gCondition1 = Nothing
    Set gCondition2 = Nothing
    Set gCondition3 = Nothing
    Set gFoundElements = Nothing

    If maxWaitSeconds <= 0 Then maxWaitSeconds = 1

    For attempts = 1 To maxWaitSeconds

RetryAttach:

        Sleep 500

        Set gDesktopElement = gUIA.GetRootElement

        Set gCondition1 = gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, "window")

        Select Case UCase(browserType)
            Case "IE": Set gCondition2 = gUIA.CreatePropertyCondition(UIA_ClassNamePropertyId, "IEFrame")
            Case Else: Set gCondition2 = gUIA.CreatePropertyCondition(UIA_ClassNamePropertyId, "Chrome_WidgetWin_1")
        End Select

        Set gCondition3 = gUIA.CreateAndCondition(gCondition1, gCondition2)

        Set gFoundElements = gDesktopElement.FindAll(TreeScope_Children, gCondition3)

        If Not gFoundElements Is Nothing And gFoundElements.length > 0 Then
            For childIndex = 0 To gFoundElements.length - 1
                Dim currentBrowserElement As IUIAutomationElement
                Set currentBrowserElement = gFoundElements.GetElement(childIndex)

                If InStr(1, UCase(currentBrowserElement.CurrentName), UCase(browserTitle), vbTextCompare) > 0 Then
                    Set AttachBrowserUIA = currentBrowserElement
                    isAttached = True
                    Exit For
                End If
            Next
        End If

        Set gFoundElements = Nothing

        If isAttached Then Exit For

    Next attempts

ExitProcedure:
    Set gCondition1 = Nothing
    Set gCondition2 = Nothing
    Set gCondition3 = Nothing
    Set gDesktopElement = Nothing

    Exit Function

ErrorHandler:
    Set AttachBrowserUIA = Nothing

    Set gCondition1 = Nothing
    Set gCondition2 = Nothing
    Set gCondition3 = Nothing
    Set gDesktopElement = Nothing

    If Err.Number <> 0 Then
        Debug.Print "Error in AttachBrowserUIA (attempt " & attempts & "): " & Err.Description & " (Error " & Err.Number & ")"
        Err.Clear
        If attempts < maxWaitSeconds Then
             Resume RetryAttach
        Else
             Debug.Print "Max retries reached for AttachBrowserUIA."
             Resume ExitProcedure
        End If
    Else
        Resume ExitProcedure
    End If
End Function


Public Function AttachBrowserUIA_NoCondition(ByVal browserTitle As String, ByVal maxWaitSeconds As Integer) As IUIAutomationElement
    ' Similar to AttachBrowserUIA, but finds ALL immediate desktop children.

    Dim childIndex As Long
    Dim attempts As Long
    Dim isAttached As Boolean

    Set gDesktopElement = Nothing
    Set gFoundElements = Nothing
    isAttached = False
    Set AttachBrowserUIA_NoCondition = Nothing

    If maxWaitSeconds <= 0 Then maxWaitSeconds = 1

    For attempts = 1 To maxWaitSeconds

RetryAttach:

        Sleep 1000

        Set gDesktopElement = gUIA.GetRootElement
        Set gFoundElements = gDesktopElement.FindAll(TreeScope_Children, gUIA.CreateTrueCondition)

        If Not gFoundElements Is Nothing And gFoundElements.length > 0 Then
            For childIndex = 0 To gFoundElements.length - 1
                 Dim currentElement As IUIAutomationElement
                 Set currentElement = gFoundElements.GetElement(childIndex)

                If InStr(1, UCase(currentElement.CurrentName), UCase(browserTitle), vbTextCompare) > 0 Then
                    Set AttachBrowserUIA_NoCondition = currentElement
                    isAttached = True
                    Exit For
                End If
            Next
        End If

        Set gFoundElements = Nothing

        If isAttached Then Exit For

    Next attempts

ExitProcedure:
     Set gDesktopElement = Nothing

    Exit Function

ErrorHandler:
    Set AttachBrowserUIA_NoCondition = Nothing

    Set gDesktopElement = Nothing

    If Err.Number <> 0 Then
        Debug.Print "Error in AttachBrowserUIA_NoCondition (attempt " & attempts & "): " & Err.Description & " (Error " & Err.Number & ")"
        Err.Clear
        If attempts < maxWaitSeconds Then
            Resume RetryAttach
        Else
             Debug.Print "Max retries reached for AttachBrowserUIA_NoCondition."
             Resume ExitProcedure
        End If
    Else
         Resume ExitProcedure
    End If
End Function

Public Function NavigateUrlInTabUIA(ByRef browserElement As IUIAutomationElement, ByVal url As String, ByVal maxWaitSeconds As Integer) As Boolean
    ' Navigates a given browser element to a URL by interacting with the address bar.
    ' Requires UIA declarations and SendKeyToWindow helper.

    Dim childIndex As Long
    Dim attempts As Long
    Dim addressBarElement As IUIAutomationElement
    Dim editElements As IUIAutomationElementArray

    NavigateUrlInTabUIA = False
    Set addressBarElement = Nothing

    On Error GoTo ErrorHandler

    If maxWaitSeconds <= 0 Then maxWaitSeconds = 1

    For attempts = 1 To maxWaitSeconds

RetryNavigate:

        Sleep 1000

        On Error Resume Next
        browserElement.SetFocus
        On Error GoTo ErrorHandler

        Set editElements = Nothing
        Set editElements = browserElement.FindAll(TreeScope_Descendants, gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, "edit"))

        If Not editElements Is Nothing And editElements.length > 0 Then
            For childIndex = 0 To editElements.length - 1
                Dim currentEditElement As IUIAutomationElement
                Set currentEditElement = editElements.GetElement(childIndex)

                If InStr(1, UCase(currentEditElement.CurrentName), UCase("address and search bar"), vbTextCompare) > 0 Then
                    Set addressBarElement = currentEditElement
                    Exit For
                End If
            Next
        End If

        Set editElements = Nothing

        If Not addressBarElement Is Nothing Then
            Set gPatternValue = Nothing
            On Error Resume Next
            Set gPatternValue = addressBarElement.GetCurrentPattern(UIA_ValuePatternId)
            On Error GoTo ErrorHandler

            If Not gPatternValue Is Nothing Then
                gPatternValue.SetValue url
                addressBarElement.SetFocus
                Call SendKeyToWindow(browserElement.CurrentName, "Enter")
                Sleep 500
                NavigateUrlInTabUIA = True
            End If
        End If

        If NavigateUrlInTabUIA Then Exit For

    Next attempts

ExitProcedure:
    Set gPatternValue = Nothing
    Set addressBarElement = Nothing
    Set editElements = Nothing

    Exit Function

ErrorHandler:
    NavigateUrlInTabUIA = False

    Set gPatternValue = Nothing
    Set addressBarElement = Nothing
    Set editElements = Nothing

    If Err.Number <> 0 Then
        Debug.Print "Error in NavigateUrlInTabUIA (attempt " & attempts & "): " & Err.Description & " (Error " & Err.Number & ")"
        Err.Clear
         If attempts < maxWaitSeconds Then
            Resume RetryNavigate
        Else
             Debug.Print "Max retries reached for NavigateUrlInTabUIA."
             Resume ExitProcedure
        End If
    Else
         Resume ExitProcedure
    End If
End Function

Public Function FindElementUIA(ByRef parentElement As IUIAutomationElement, ByVal propertyType As String, Optional ByVal controlType As String, Optional ByVal propertyValue As String, Optional ByVal maxWaitSeconds As Integer, Optional ByVal elementIndex As Integer) As IUIAutomationElement
    ' Generic function to find a single element within a parent element.
    ' Searches by various UIA properties.
    ' Requires UIA declarations and conditions.

    Dim attempts As Long
    Dim foundElements As IUIAutomationElementArray
    Dim isFound As Boolean

    Set FindElementUIA = Nothing
    isFound = False

    On Error GoTo ErrorHandler

    If maxWaitSeconds <= 0 Then maxWaitSeconds = 1
    If IsMissing(elementIndex) Then elementIndex = 0

    For attempts = 1 To maxWaitSeconds

RetryFind:

        Set foundElements = Nothing
        Set gCondition1 = Nothing

        Select Case UCase(propertyType)

            Case PROP_NAME
                 If controlType = "" Then
                    Set gCondition1 = gUIA.CreatePropertyCondition(UIA_NamePropertyId, propertyValue)
                    Set foundElements = parentElement.FindAll(TreeScope_Descendants, gCondition1)
                 Else
                    Set gCondition1 = gUIA.CreateAndCondition(gUIA.CreatePropertyCondition(UIA_NamePropertyId, propertyValue), gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, controlType))
                    Set FindElementUIA = parentElement.FindFirst(TreeScope_Descendants, gCondition1)
                    isFound = Not FindElementUIA Is Nothing
                 End If

            Case PROP_CLASSNAME
                 If controlType = "" Then
                    Set gCondition1 = gUIA.CreatePropertyCondition(UIA_ClassNamePropertyId, propertyValue)
                    Set foundElements = parentElement.FindAll(TreeScope_Descendants, gCondition1)
                 Else
                    Set gCondition1 = gUIA.CreateAndCondition(gUIA.CreatePropertyCondition(UIA_ClassNamePropertyId, propertyValue), gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, controlType))
                    Set FindElementUIA = parentElement.FindFirst(TreeScope_Descendants, gCondition1)
                    isFound = Not FindElementUIA Is Nothing
                 End If

            Case PROP_AUTOMATIONID
                 If controlType = "" Then
                    Set gCondition1 = gUIA.CreatePropertyCondition(UIA_AutomationIdPropertyId, propertyValue)
                    Set foundElements = parentElement.FindAll(TreeScope_Descendants, gCondition1)
                 Else
                    Set gCondition1 = gUIA.CreateAndCondition(gUIA.CreatePropertyCondition(UIA_AutomationIdPropertyId, propertyValue), gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, controlType))
                    Set FindElementUIA = parentElement.FindFirst(TreeScope_Descendants, gCondition1)
                    isFound = Not FindElementUIA Is Nothing
                 End If

            Case PROP_LOCALISEDCONTROLTYPE
                 If propertyValue = "" Then
                    Set gCondition1 = gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, controlType)
                    Set foundElements = parentElement.FindAll(TreeScope_Descendants, gCondition1)
                 Else
                    Set gCondition1 = gUIA.CreateAndCondition(gUIA.CreatePropertyCondition(UIA_NamePropertyId, propertyValue), gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, controlType))
                    Set FindElementUIA = parentElement.FindFirst(TreeScope_Descendants, gCondition1)
                    isFound = Not FindElementUIA Is Nothing
                 End If

            Case Else
                Debug.Print "FindElementUIA: Invalid propertyType '" & propertyType & "'"
                GoTo ExitLoop

        End Select

        If Not foundElements Is Nothing And foundElements.length > 0 Then
            Dim targetIndex As Long
            If CInt(elementIndex) <> 0 Then
                 targetIndex = CInt(elementIndex)
            Else
                 targetIndex = 0
            End If

            If targetIndex >= 0 And targetIndex < foundElements.length Then
                 Set FindElementUIA = foundElements.GetElement(targetIndex)
                 isFound = True
            Else
                 Debug.Print "FindElementUIA: elementIndex " & elementIndex & " is out of bounds (Array length " & foundElements.length & ")"
            End If
        End If

ExitLoop:

        If isFound Then Exit For

        Sleep 500

    Next attempts

ExitProcedure:
    Set foundElements = Nothing
    Set gCondition1 = Nothing
    Set gCondition2 = Nothing
    Set gCondition3 = Nothing

    Exit Function

ErrorHandler:
    Set FindElementUIA = Nothing
    Set foundElements = Nothing
    Set gCondition1 = Nothing
    Set gCondition2 = Nothing
    Set gCondition3 = Nothing

    If Err.Number <> 0 Then
        Debug.Print "Error in FindElementUIA (attempt " & attempts & "): " & Err.Description & " (Error " & Err.Number & ")"
        Err.Clear
        If attempts < maxWaitSeconds Then
            Resume RetryFind
        Else
            Debug.Print "Max retries reached for FindElementUIA."
            Resume ExitProcedure
        End If
    Else
        Resume ExitProcedure
    End If
End Function


Public Function FindElementByTypeUIA(ByRef parentElement As IUIAutomationElement, ByVal controlType As String, ByVal nameValue As String, ByVal maxWaitSeconds As Integer, Optional ByVal elementIndex As Integer) As UIAutomationClient.IUIAutomationElement
    ' Finds a single element of a specific control type whose name matches a value.
    ' Requires UIA declarations.

    Dim attempts As Long
    Dim typedElements As IUIAutomationElementArray
    Dim isFound As Boolean

    Set FindElementByTypeUIA = Nothing
    isFound = False

    On Error GoTo ErrorHandler

    If maxWaitSeconds <= 0 Then maxWaitSeconds = 1
    If IsMissing(elementIndex) Then elementIndex = 0

    For attempts = 1 To maxWaitSeconds

RetryFind:

        ' Sleep 1000 ' Original code had Sleep here, commented out.

        On Error Resume Next
        parentElement.SetFocus
        On Error GoTo ErrorHandler


        Set typedElements = Nothing
        Set typedElements = parentElement.FindAll(TreeScope_Descendants, gUIA.CreatePropertyCondition(UIA_LocalizedControlTypePropertyId, controlType))

        If Not typedElements Is Nothing And typedElements.length > 0 Then
            Dim childIndex As Long
            For childIndex = 0 To typedElements.length - 1
                 Dim currentElement As IUIAutomationElement
                 Set currentElement = typedElements.GetElement(childIndex)

                If UCase(currentElement.CurrentName) = UCase(nameValue) Then
                    Set FindElementByTypeUIA = currentElement
                    isFound = True
                    ' Application.Wait VBA.DateAdd("s", 2, Now) ' Original code waits 2s after finding.
                    Exit For
                End If

            Next childIndex
        End If
        Set typedElements = Nothing


        If isFound Then Exit For

        Sleep 500

    Next attempts

ExitProcedure:
    Set typedElements = Nothing

    Exit Function

ErrorHandler:
    Set FindElementByTypeUIA = Nothing
    Set typedElements = Nothing

    If Err.Number <> 0 Then
        Debug.Print "Error in FindElementByTypeUIA (attempt " & attempts & "): " & Err.Description & " (Error " & Err.Number & ")"
        Err.Clear
        If attempts < maxWaitSeconds Then
            Resume RetryFind
        Else
            Debug.Print "Max retries reached for FindElementByTypeUIA."
            Resume ExitProcedure
        End If
    Else
         Resume ExitProcedure
    End If
End Function


Public Function SetTextUIA(ByRef targetElement As IUIAutomationElement, ByVal textValue As String, ByVal patternType As String, ByVal maxWaitSeconds As Integer) As Boolean
    ' Sets the text value of a UI Automation element using ValuePattern or LegacyIAccessiblePattern.
    ' Requires UIA declarations and pattern variables.

    Dim attempts As Long
    SetTextUIA = False

    On Error GoTo ErrorHandler

    If maxWaitSeconds <= 0 Then maxWaitSeconds = 1

    For attempts = 1 To maxWaitSeconds

RetrySetText:

        On Error Resume Next
        Select Case UCase(patternType)
            Case PATTERN_LEGACY
                Set gPatternLegacyAccessible = Nothing
                Set gPatternLegacyAccessible = targetElement.GetCurrentPattern(UIA_LegacyIAccessiblePatternId)
                If Not gPatternLegacyAccessible Is Nothing Then
                     gPatternLegacyAccessible.SetValue textValue
                     SetTextUIA = True
                End If

            Case PATTERN_VALUE
                Set gPatternValue = Nothing
                Set gPatternValue = targetElement.GetCurrentPattern(UIA_ValuePatternId)
                If Not gPatternValue Is Nothing Then
                     gPatternValue.SetValue textValue
                     SetTextUIA = True
                End If

            Case Else
                Debug.Print "SetTextUIA: Invalid Pattern '" & patternType & "'"
                 SetTextUIA = False
                GoTo ExitLoopSuccessCheck

        End Select
        On Error GoTo ErrorHandler

ExitLoopSuccessCheck:
        If SetTextUIA Then Exit For

        Sleep 500

    Next attempts

ExitProcedure:
    Set gPatternLegacyAccessible = Nothing
    Set gPatternValue = Nothing

    Exit Function

ErrorHandler:
    SetTextUIA = False

    Set gPatternLegacyAccessible = Nothing
    Set gPatternValue = Nothing

    If Err.Number <> 0 Then
        Debug.Print "Error in SetTextUIA (attempt " & attempts & "): " & Err.Description & " (Error " & Err.Number & ")"
        Err.Clear
        If attempts < maxWaitSeconds Then
            Resume RetrySetText
        Else
            Debug.Print "Max retries reached for SetTextUIA."
            Resume ExitProcedure
        End If
    Else
         Resume ExitProcedure
    End If
End Function


Public Function ClickUIA(ByRef targetElement As IUIAutomationElement, ByVal patternType As String, ByVal maxWaitSeconds As Integer) As Boolean
    ' Clicks a UI Automation element using various patterns (Invoke, Legacy, Expand/Collapse).
    ' Requires UIA declarations and pattern variables, and Sleep.

    Dim attempts As Long
    ClickUIA = False

    On Error GoTo ErrorHandler

    If maxWaitSeconds <= 0 Then maxWaitSeconds = 1

    For attempts = 1 To maxWaitSeconds

RetryClick:

        On Error Resume Next
        Select Case UCase(patternType)
            Case PATTERN_INVOKE
                Set gPatternInvoke = Nothing
                Set gPatternInvoke = targetElement.GetCurrentPattern(UIA_InvokePatternId)
                If Not gPatternInvoke Is Nothing Then
                    gPatternInvoke.Invoke
                    Sleep 500
                    ClickUIA = True
                End If

            Case PATTERN_LEGACY
                Set gPatternLegacyAccessible = Nothing
                Set gPatternLegacyAccessible = targetElement.GetCurrentPattern(UIA_LegacyIAccessiblePatternId)
                 If Not gPatternLegacyAccessible Is Nothing Then
                    gPatternLegacyAccessible.DoDefaultAction
                    Sleep 500
                    ClickUIA = True
                End If

            Case PATTERN_EXPAND_COLLAPSE
                Set gPatternExpand = Nothing
                Set gPatternExpand = targetElement.GetCurrentPattern(UIA_ExpandCollapsePatternId)
                If Not gPatternExpand Is Nothing Then
                     gPatternExpand.expand
                     Sleep 500
                     ClickUIA = True
                End If

            Case "COLLAPSE"
                 Set gPatternCollapse = Nothing
                 Set gPatternCollapse = targetElement.GetCurrentPattern(UIA_ExpandCollapsePatternId)
                 If Not gPatternCollapse Is Nothing Then
                     gPatternCollapse.Collapse
                     Sleep 500
                     ClickUIA = True
                 End If

            Case Else
                Debug.Print "ClickUIA: Invalid Pattern '" & patternType & "'"
                ClickUIA = False
                GoTo ExitLoopSuccessCheck

        End Select
        On Error GoTo ErrorHandler

ExitLoopSuccessCheck:
        If ClickUIA Then Exit For

        Sleep 500

    Next attempts

ExitProcedure:
    Set gPatternInvoke = Nothing
    Set gPatternLegacyAccessible = Nothing
    Set gPatternExpand = Nothing
    Set gPatternCollapse = Nothing

    Exit Function

ErrorHandler:
    ClickUIA = False

    Set gPatternInvoke = Nothing
    Set gPatternLegacyAccessible = Nothing
    Set gPatternExpand = Nothing
    Set gPatternCollapse = Nothing

    If Err.Number <> 0 Then
        Debug.Print "Error in ClickUIA (attempt " & attempts & "): " & Err.Description & " (Error " & Err.Number & ")"
        Err.Clear
         If attempts < maxWaitSeconds Then
            Resume RetryClick
        Else
             Debug.Print "Max retries reached for ClickUIA."
             Resume ExitProcedure
        End If
    Else
         Resume ExitProcedure
    End If
End Function


Public Sub EnsureNumLockOn()
    ' Ensures Num Lock is turned ON if it's currently OFF.
    ' Uses keybd_event and GetKeyState.
    On Error GoTo ErrorHandler

    Dim keyStateBuffer(0 To 255) As Byte
    If Not (GetKeyState(VK_NUMLOCK) And 1) Then
        keybd_event VK_NUMLOCK, NUM_LOCK_SCAN_CODE, KEYEVENTF_EXTENDEDKEY, 0&
        keybd_event VK_NUMLOCK, NUM_LOCK_SCAN_CODE, KEYEVENTF_EXTENDEDKEY Or KEYEVENTF_KEYUP, 0&
    End If

ExitProcedure:
    Exit Sub

ErrorHandler:
    Debug.Print "Error in EnsureNumLockOn: " & Err.Description & " (Error " & Err.Number & ")"
    Resume ExitProcedure
End Sub

' Add any other helper functions you need from your original VCG_ code here,
' remembering to update their names and any internal calls to other helper functions.
