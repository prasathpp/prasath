# --- Phase 3: Generating Final Report ---
print("\n--- Phase 3: Generating Final Account-Wise Report ---")
output_rows = []
for account_number, data in account_data.items():
    # .get() is used to safely access keys that might not exist for a failed item
    base_info = data.get('base_info', {})
    
    # --- THE DEFINITIVE FIX: Build clean, new dictionaries for serialization ---
    
    # 1. Create a clean dictionary for the 'Basic Info' JSON string.
    #    This new dict has no link to the original 'data' object.
    clean_base_info_for_json = {
        key: value for key, value in base_info.items() if key != 'Hit Date DT'
    }
    
    # 2. Create a clean list of dictionaries for the 'Transaction Data' JSON string.
    clean_transactions_for_json = data.get('transactions', [])

    # 3. Create a clean dictionary for the 'Unpaid Data' JSON string.
    clean_unpaids_for_json = data.get('mainframe_unpaids', {})

    # Create a dictionary for the new, structured row
    row_data = {
        # Key Identifier Columns from the original base_info
        'Case Number': base_info.get('Case Number'),
        'Sort Code': str(base_info.get('Sort Code', '')).zfill(6),
        'Account': str(base_info.get('Account', '')).zfill(8),
        'Brand': base_info.get('Brand'),
        
        # Diagnostic and Calculated Columns
        'Processing Status': data.get('mainframe_status'),
        'Limit': data.get('limit'),
        'Diary Refund Amount': data.get('diary_refund_amount'),
        'Replace Refund Amount': data.get('replace_refund_amount'),
        'Refund (Manual) Amount': data.get('refund_manual_amount'),
        'Diary Date': data.get('diary_date'),

        # Richly Formatted JSON Columns using the new, clean objects
        'Basic Info': json.dumps(clean_base_info_for_json, indent=4, default=convert_numpy_types),
        'Transaction Data': json.dumps(clean_transactions_for_json, indent=4, default=convert_numpy_types),
        'Unpaid Data': json.dumps(clean_unpaids_for_json, indent=4, default=convert_numpy_types),
    }
    output_rows.append(row_data)

# Create the final DataFrame from our list of structured rows
output_df = pd.DataFrame(output_rows)

# Define the exact column order for the final Excel file
final_column_order = [
    'Case Number', 'Sort Code', 'Account', 'Brand', 'Processing Status', 'Limit',
    'Diary Refund Amount', 'Replace Refund Amount', 'Refund (Manual) Amount', 'Diary Date',
    'Basic Info', 'Transaction Data', 'Unpaid Data'
]

# Ensure all columns exist before trying to reorder, to prevent errors
existing_cols = [col for col in final_column_order if col in output_df.columns]
output_df = output_df[existing_cols]

# Save the final, structured report
output_df.to_excel(r"C:\Users\raosx\Downloads\limit_output_final_structured.xlsx", index=False)


print("\nScript finished successfully.")
if mf: mf.terminate()
