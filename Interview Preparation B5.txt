# --- Phase 3: Generating Final Report ---
print("\n--- Phase 3: Generating Final Account-Wise Report ---")
output_rows = []
for account_number, data in account_data.items():
    # .get() is used to safely access keys that might not exist for a failed item
    base_info = data.get('base_info', {})
    
    # --- THE DEFINITIVE FIX: Manually build a clean dictionary for JSON ---
    # This guarantees there are no circular references from pandas objects.
    clean_base_info_for_json = {}
    for key, value in base_info.items():
        # Use our converter to ensure every value is a standard Python type
        clean_base_info_for_json[key] = convert_numpy_types(value)

    # We can safely remove the temporary datetime object now
    if 'Hit Date DT' in clean_base_info_for_json:
        del clean_base_info_for_json['Hit Date DT']

    # Create a dictionary for the new, structured row
    row_data = {
        # --- 1. Key Identifier Columns ---
        'Case Number': base_info.get('Case Number'),
        'Sort Code': str(base_info.get('Sort Code', '')).zfill(6),
        'Account': str(base_info.get('Account', '')).zfill(8),
        'Brand': base_info.get('Brand'),
        
        # --- 3. Diagnostic and Calculated Columns ---
        'Processing Status': data.get('mainframe_status'),
        'Limit': data.get('limit'),
        'Diary Refund Amount': data.get('diary_refund_amount'),
        'Replace Refund Amount': data.get('replace_refund_amount'),
        'Refund (Manual) Amount': data.get('refund_manual_amount'),
        'Diary Date': data.get('diary_date'),

        # --- 2. Richly Formatted JSON Columns ---
        # Now we pass the guaranteed-clean dictionary to json.dumps
        'Basic Info': json.dumps(clean_base_info_for_json, indent=4, default=str), # Use default=str as a final fallback
        'Transaction Data': json.dumps(data.get('transactions'), indent=4, default=str),
        'Unpaid Data': json.dumps(data.get('mainframe_unpaids'), indent=4, default=str),
    }
    output_rows.append(row_data)

# Create the final DataFrame from our list of structured rows
output_df = pd.DataFrame(output_rows)

# Define the exact column order for the final Excel file
final_column_order = [
    'Case Number', 'Sort Code', 'Account', 'Brand', 'Processing Status', 'Limit',
    'Diary Refund Amount', 'Replace Refund Amount', 'Refund (Manual) Amount', 'Diary Date',
    'Basic Info', 'Transaction Data', 'Unpaid Data'
]

# Ensure all columns exist before trying to reorder, to prevent errors
existing_cols = [col for col in final_column_order if col in output_df.columns]
output_df = output_df[existing_cols]

# Save the final, structured report
output_df.to_excel(r"C:\Users\raosx\Downloads\limit_output_final_structured.xlsx", index=False)


print("\nScript finished successfully.")
# if mf: mf.terminate()
