import base64
import getpass

from py3720_local import Emulator
import time
import os
import pandas as pd
import datetime


DEBUG = True




class MFRobot(Emulator):

    def __init__(self, visible=False, timeout=60, app=None, args=None,initcommand="ncaqpc"):
        Emulator.__init__(self, visible, timeout, app, args)
        self.host_name = 'tn3270.plexq1.server.rbsgrp.net:4992'
        self.initial_command = initcommand
        self.application = 'PRCIN#T# - NWB PRODUCTION CICS ACCESS'


    def connect_n_login(
            self,
            racf,
            password):

        self.racf = racf

        self.connect(self.host_name)
        self.wait_for_field()

        self.input_text_into_field('====>', self.initial_command)
        self.send_enter()
        if 'nca' in self.initial_command:
            self.input_text_into_field('USERID ==>', racf)
            self.input_text_into_field('PASSWORD ==>', password)
        else:
            self.input_text_into_field('Userid   ==>', racf)
            self.input_text_into_field('Password ==>', password)

        screen_content = self.get_screen_text()
        self.send_enter()
        self.send_pf3()

        if self.wait_for_text('APPLICATION SELECTION MENU'):
            if self.wait_for_text('SESSION', wait_for=1):
                self.application_selection_menu_active_session(application_name=self.application)
            else:
                self.application_selection_menu(application_name=self.application)
        
        else:
            time.sleep(2)
            screen_content = self.get_screen_text()
            return 'Login Failed', screen_content


    def application_selection_menu_active_session(self, application_name):
        if self.wait_for_text(application_name):
            self.choose_row(application_name, 11)
            screen_content = self.get_screen_text()
            self.send_enter()

            if self.wait_for_text('Unable to recreate previous screen image'):
                time.sleep(1)
                self.send_pf3()
                time.sleep(1)
                
                if self.wait_for_text('ORGANISATIONAL MODEL INDEX', wait_for=1):
                    self.organisational_model_index()
                elif self.wait_for_text('Option Handler Function Screen', wait_for=1):
                    self.option_handler_function_screen()
                    self.organisational_model_index()
                else:
                    self.black_screen()

                
            return f'Screen 2: Ok', screen_content
        else:
            time.sleep(2)
            return f'Screen 2: Application: {application_name} has not been found'


    def application_selection_menu(self, application_name):
        if self.wait_for_text(application_name):
            self.choose_row(application_name, 11)
            screen_content = self.get_screen_text()
            self.send_enter()            

            time.sleep(1)
            self.control_window()
            self.black_screen()
            self.option_handler_function_screen()
            self.organisational_model_index()
            return f'Screen 2: Ok', screen_content
        else:
            time.sleep(1)
            return f'Screen 2: Application: {application_name} has not been found'


    def control_window(self):
        if self.wait_for_text(f'Userid : {self.racf}'):
            screen_content = self.get_screen_text()
            self.send_enter()
            time.sleep(1)
            return 'Screen 3: Ok', screen_content
        else:
            time.sleep(1)
            screen_content = self.get_screen_text()
            return 'Screen 3: Details incorrect', screen_content

    def black_screen(self):
        time.sleep(1)
        self.fill_field(1, 1, 'start', 5)
        self.send_enter()
        time.sleep(1)
        return 'Screen 4: Ok'

    def option_handler_function_screen(self):
        if self.wait_for_text('Option Handler Function Screen'):
            self.input_text_into_field('Select Option', '109')
            screen_content = self.get_screen_text()
            self.send_enter()
            time.sleep(1)
            return 'Screen 5: Ok', screen_content
        else:
            time.sleep(1)
            screen_content = self.get_screen_text()
            return 'Screen 5: Details have not been found', screen_content

    def organisational_model_index(self):
        if self.wait_for_text('ORGANISATIONAL MODEL INDEX'):
            self.input_text_into_field('Select Option', '1')
            screen_content = self.get_screen_text()
            self.send_enter()
            time.sleep(1)
            return 'Screen 6: Ok', screen_content
        else:
            time.sleep(1)
            screen_content = self.get_screen_text()
            return 'Screen 6: Details have not found', screen_content

    def organisational_model_maint(self, index='', id='', qualifier=''):
        # Check if we are on the Organisational Model Maint page
        if self.wait_for_text('ORGANISATIONAL MODEL MAINT') and self.wait_for_text('EMPLOYEE') and self.wait_for_text(
                'INDEX'):
            # If so, input values in the required fields
            self.input_text_into_field('INDEX', index)
            self.input_text_into_field('ID', id)
            self.input_text_into_field('QUALIFIER', qualifier)

            # Press Enter
            self.send_enter()



    def get_screen_text(self, ysize=25, xsize=80):
        screen_text = ""
        for ypos in range(1, ysize):
            screen_text += str(self.string_get(ypos, 1, xsize))
            screen_text += "\n"
        return screen_text

    def get_screen_text_test(self, ysize=25, xsize=80):
        index = 0
        screen_text = ""
        for ypos in range(1, ysize):
            screen_text += f'RowNumber {index+1} ' + str(self.string_get(ypos, 1, xsize))
            screen_text += "\n"
            index += 1040
        return screen_text


    def find_last_line(self, ysize=25, xsize=80):
        # screen_text = ""
        for ypos in range(1, ysize):
            screen_text = str(self.string_get(ypos, 1, xsize))
            # print(ypos, len(screen_text), screen_text)
            if '_         ' in screen_text:
                last_line = ypos
        return last_line


    def wait_for_text(self, target_text, wait_for=3):
        waited_for = 0
        while waited_for < wait_for:
            if target_text in self.get_screen_text():
                return True
            time.sleep(1)
            waited_for += 1
        return False

    def text_position(self, target_text):
        text_length = int(len(target_text))
        screen_content = self.get_screen_text()

        text_position = None
        for row, line in enumerate(screen_content.split('\n'), start=1):
            if target_text in line:
                column = line.index(target_text) + 1 + text_length + 1
                text_position = (row, column)
                break

        if text_position is not None:
            # print(f"Text position: row={text_position[0]}, column={text_position[1]}")
            return text_position
        else:
            # print("Text not found")
            return None

    def input_text_into_field(self, field_name, input):
        if self.wait_for_text(field_name):
            row, column = self.text_position(field_name)
            text_lenght = len(input)
            self.fill_field(row, column, tosend=input, length=text_lenght)


    def choose_row(self, target_text, xpos):
        if self.wait_for_text(target_text):
            row, column = self.text_position(target_text)
            self.move_to(row, xpos)


    def find_cost_centre(self, target_text, xpos):
        if self.wait_for_text(target_text):
            row, column = self.text_position(target_text)
            self.move_to(row-1, xpos)

            time.sleep(2)

    def find_record(self, param1, param2, xpos):
        screen_content = self.get_screen_text_test().split('\n')
        records = [screen_content[i:i + 2] for i in range(0, len(screen_content), 2)]

        for index, record in enumerate(records):
            matches = param1
            matches2 = param2

            if all([x in record[0] for x in matches]) and all([x in record[1] for x in matches2]):
                position = record[0][10:12]
                self.move_to(ypos=int(position), xpos=xpos)


    def return_to_screen(self, text, wait_for=1):
        while not self.wait_for_text(text, wait_for=wait_for):
            self.send_pf3()


    def move_forward(self, text):
        while not self.wait_for_text(text):
            self.send_pf8()

    def move_forward_test(self, param1, param2):
        while not self.test_function(param1=param1, param2=param2):
            self.send_pf8()
            if self.wait_for_text('CANNOT PAGE FORWARD',wait_for=2):
                break

    def get_pass(self, name):
        try:
            with open("{}.txt".format(name)) as f:
                mylist = f.read().splitlines()
        except IOError:
            print("Error: Could not find file or read data")
        else:
            print("Text file read succesfully")
            f.close()

        racf = mylist[0].upper()
        password = mylist[1]
        return racf, password

    def test_function(self, param1, param2):
        screen_content = self.get_screen_text_test().split('\n')
        records = [screen_content[i:i + 2] for i in range(0, len(screen_content), 2)]

        for index, record in enumerate(records):
            matches = param1
            # print(matches)
            matches2 = param2
            # print(matches2)

            if all([x in record[0] for x in matches]) and all([x in record[1] for x in matches2]):
                return True
        return False

    def cost_centre_open_date(self, cc_open_date):

        today = datetime.datetime.strptime(cc_open_date, '%Y-%m-%d')
        yesterday = today - datetime.timedelta(days=1)

        yesterday = yesterday.strftime('%Y-%m-%d')
        today = today.strftime('%Y-%m-%d')

        close_date = (yesterday[0:4], yesterday[5:7], yesterday[8:10])

        open_date = (today[0:4], today[5:7], today[8:10])

        return close_date, open_date

    def get_previous_day_date(self):
        today = datetime.datetime.today()
        yesterday = today - datetime.timedelta(1)
        yesterday = yesterday.strftime('%Y-%m-%d')
        yesterday = (yesterday[0:4], yesterday[5:7], yesterday[8:10])

        return yesterday

    def get_timestamp(self):
        today = datetime.datetime.today()
        today = today.strftime('%Y%m%d_%H%M%S')
        return today

    def createFieldsTemplate(self, scenario: str, item=None, dataframe=None, startDate=None, endDate=None):
        """"
            Creates list of fields to be filled in along with values
        """

        conditions = []
        if scenario == 'create_new_cc':
            conditions.append({
                'COST CENTRE NO :': item,
                'CONSOLIDATED     :': 'N',
                'START DATE       :': startDate,
                'SUBMIT': 's'

            })

        elif scenario == 'deactivate_pc':
            conditions.append({
                'END DATE    :': endDate,
                'SUBMIT': 's'
            })

        elif scenario == 'deactivate_cc':
            conditions.append({
                'END DATE       :': endDate,
                'SUBMIT': 's'
            })

        return conditions

    def fill_fields_by_values(self, scenario, item=None, startDate=None, endDate=None):

        listOfDicts = self.createFieldsTemplate(scenario=scenario, item=item, startDate=startDate, endDate=endDate)

        for dictionary in listOfDicts:
            for key, value in dictionary.items():
                self.input_text_into_field(key, value)

    def get_screen_message(self, line=23):
        screen_content = self.get_screen_text().split('\n')
        message = screen_content[line].strip()

        return message

    def activate_deactivate_template(self, request_form, index, scenario, endDate):
        output = []
        for request in request_form:
            self.organisational_model_maint(index=index, id=request[0])

            # COST CENTRE ID must be captured from the screen to be used to approve change of END DATE
            screen_content = self.get_screen_text().split('\n')
            cost_centre_id = screen_content[2][20:35].strip()

            self.fill_fields_by_values(scenario=scenario, endDate=endDate)
            self.send_enter()
            message = self.get_screen_message()
            print(f'{request[0]} {message}')
            output.append((request[0], message))

            # Portfolio Code
            if f'''PORTFOLIO  {request[0]} NOT RM'D BY EMPL POSN''' in message:
                self.send_enter()
                message = self.get_screen_message()
                print(f'{request[0]} {message}')
                output.append((request[0], message))

                if f'''PORTFOLIO  {request[0]} NOT CCA CREDTR CCA CREDTR''' in message:
                    self.send_enter()

                    if self.wait_for_text('ORGANISATIONAL MODEL MAINT', wait_for=2):
                        message = self.get_screen_message(line=22)
                        print(f'{request[0]} {message}')
                        output.append((request[0], message))

            # Cost Centre
            elif f'''COST CNTR  {cost_centre_id} NOT OWNED BY EMPL POSN''' in message:
                self.send_enter()
                message = self.get_screen_message()
                print(f'{request[0]} {message}')
                output.append((request[0], message))
            #
            else:
                self.return_to_screen(text='ORGANISATIONAL MODEL MAINT', wait_for=2)

        return output

    def create_new_cc(self, request_form):
        output = []
        for request in request_form:
            # Clear ID field
            self.input_text_into_field('ID', '')
            self.organisational_model_maint(index='04', qualifier='new')

            # COST CENTRE ID must be captured from the screen to be used to approve creating of new CC
            screen_content = self.get_screen_text().split('\n')
            cost_centre_id = screen_content[2][20:35].strip()

            self.fill_fields_by_values(scenario='create_new_cc', item=request[0], startDate=request[1].strftime('%d%m%Y'))
            self.send_enter()
            message = self.get_screen_message()
            print(f'{request[0]} {message}')
            output.append((request[0], message))

            if f'''COST CNTR  {cost_centre_id} NOT OWNED BY EMPL POSN''' in message:
                self.send_enter()
                message = self.get_screen_message()
                print(f'{request[0]} {message}')
                output.append((request[0], message))
            else:
                self.return_to_screen(text='ORGANISATIONAL MODEL MAINT', wait_for=2)
        return output

if __name__ == "__main__":
    pass


# -*- coding: utf-8 -*-

from __future__ import absolute_import
from __future__ import unicode_literals

import logging
import os
import six
import socket
import subprocess
import time
import warnings
import errno

log = logging.getLogger(__name__)


try:
    BrokenPipeError
except NameError:

    class BrokenPipeError(Exception):
        pass


"""
    Python 3+ note: unicode strings should be used when communicating with the Emulator methods.
    Ascii is used internally when reading from or writing to the 3270 emulator (this includes
    reading lines, constructing data to write, reading statuses).
"""


class CommandError(Exception):
    pass


class TerminatedError(Exception):
    pass


class WaitError(Exception):
    pass


class KeyboardStateError(Exception):
    pass


class FieldTruncateError(Exception):
    pass


class Command(object):
    """
        Represents a x3270 script command
    """

    def __init__(self, app, cmdstr):
        if isinstance(cmdstr, six.text_type):
            warnings.warn("Commands should be byte strings", stacklevel=3)
            cmdstr = cmdstr.encode("ascii")
        self.app = app
        self.cmdstr = cmdstr
        self.status_line = None
        self.data = []

    def execute(self):
        print("in execute" , self.cmdstr)
        self.app.write(self.cmdstr + b"\n")

        # x3270 puts data lines (if any) on stdout prefixed with 'data: '
        # followed by two more lines without the prefix.
        # 1: status of the emulator
        # 2: 'ok' or 'error' indicating whether the command succeeded or failed
        while True:
            line = self.app.readline()
            print("line" , line)
            log.debug("stdout line: %s", line.rstrip())
            if not line.startswith("data:".encode("ascii")):
                # ok, we are at the status line
                self.status_line = line.rstrip()
                result = self.app.readline().rstrip()
                log.debug("result line: %s", result)
                return self.handle_result(result.decode("ascii"))

            # remove the 'data: ' prefix and trailing newline char(s) and store
            self.data.append(line[6:].rstrip("\n\r".encode("ascii")))

    def handle_result(self, result):
        # should receive 'ok' for almost everything, but Quit returns a '' for
        # some reason
        if result == "" and self.cmdstr == b"Quit":
            return
        if result == "ok":
            return
        if result != "error":
            raise ValueError(
                'expected "ok" or "error" result, but received: {0}'.format(result)
            )

        msg = b"[no error message]"
        if self.data:
            msg = "".encode("ascii").join(self.data).rstrip()
        raise CommandError(msg.decode("ascii"))


class Status(object):
    """
        Represents a status line as returned by x3270 following a command
    """

    def __init__(self, status_line):
        if not status_line:
            status_line = (" " * 12).encode("ascii")
        parts = status_line.split(" ".encode("ascii"))
        self.as_string = status_line.rstrip().decode("ascii")
        self.keyboard = parts[0] or None
        self.screen_format = parts[1] or None
        self.field_protection = parts[2] or None
        self.connection_state = parts[3] or None
        self.emulator_mode = parts[4] or None
        self.model_number = parts[5] or None
        self.row_number = parts[6] or None
        self.col_number = parts[7] or None
        self.cursor_row = parts[8] or None
        self.cursor_col = parts[9] or None
        self.window_id = parts[10] or None
        self.exec_time = parts[11] or None

    def __str__(self):
        return "STATUS: {0}".format(self.as_string)


class ExecutableApp(object):
    executable = None
    args = ["-xrm", "s3270.unlockDelay: False"]

    def __init__(self, args):
        if args:
            self.args = ExecutableApp.args + args
        self.sp = None
        self.spawn_app()

    def spawn_app(self):
        args = [self.executable] + self.args
        self.sp = subprocess.Popen(
            args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )

    def connect(self, host):
        """ this is a no-op for all but wc3270 """
        return False

    def close(self):
        if self.sp.poll() is None:
            self.sp.terminate()
        return_code = self.sp.returncode or self.sp.poll()
        log.debug("return code: %d", return_code)
        return return_code

    def write(self, data):
        self.sp.stdin.write(data)
        self.sp.stdin.flush()

    def readline(self):
        return self.sp.stdout.readline()


class X3270App(ExecutableApp):
    executable = "x3270"
    # Per Paul Mattes, in the first days of x3270, there were servers that
    # would unlock the keyboard before they had processed the command. To
    # work around that, when AID commands are sent, there is a 350ms delay
    # before the command returns. This arg turns that feature off for
    # performance reasons.
    args = ["-xrm", "x3270.unlockDelay: False", "-script"]


class S3270App(ExecutableApp):
    executable = "s3270"
    # see notes for args in x3270App
    args = ["-xrm", "s3270.unlockDelay: False"]


class NotConnectedException(Exception):
    pass


class Wc3270App(ExecutableApp):
    executable = "wc3270"
    # see notes for args in x3270App
    args = ["-xrm", "wc3270.unlockDelay: False"]
    script_port = 17938

    def __init__(self, args):
        if args:
            self.args = Wc3270App.args + args
        self.sp = None
        self.socket_fh = None

    def connect(self, host):
        self.spawn_app(host)
        self.make_socket()
        return True

    def close(self):
        # failing to close the socket ourselves will result in a ResourceWarning
        self.socket.close()

    def spawn_app(self, host):
        args = ["start", "/wait", self.executable] + self.args
        args.extend(["-scriptport", str(self.script_port), host])
        self.sp = subprocess.Popen(
            args,
            shell=True,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )

    def make_socket(self):
        self.socket = sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        count = 0
        while count < 15:
            try:
                sock.connect(("localhost", self.script_port))
                break
            except socket.error as e:
                log.warn(e)
                if e.errno != errno.ECONNREFUSED:
                    raise
                time.sleep(1)
                count += 1
        # open a file handle for the socket that can both read and write, using bytestrings
        self.socket_fh = sock.makefile(mode="rwb")

    def write(self, data):
        if self.socket_fh is None:
            raise NotConnectedException
        self.socket_fh.write(data)
        self.socket_fh.flush()

    def readline(self):
        if self.socket_fh is None:
            raise NotConnectedException
        return self.socket_fh.readline()


class Ws3270App(ExecutableApp):
    executable = "ws3270"
    # see notes for args in x3270App
    args = ["-xrm", "ws3270.unlockDelay: False"]


class EmulatorBase(object):
    def __init__(self, visible=False, timeout=30, app=None):
        raise Exception("EmulatorBase has been replaced by Emulator.  See readme.rst.")


class Emulator(object):
    """
        Represents an x/s3270 emulator subprocess and provides an API for interacting
        with it.
    """

    def __init__(self, visible=False, timeout=30, app=None, args=None):
        """
            Create an emulator instance

            `visible` controls which executable will be used.
            `timeout` controls the timeout paramater to any Wait() command sent
                to x3270.
            `args` allows sending parameters to the emulator executable 
        """
        self.app = app or self.create_app(visible, args)
        self.is_terminated = False
        self.status = Status(None)
        self.timeout = timeout
        self.last_host = None

    def __del__(self):
        """
            Since an emulator creates a process (and sometimes a socket handle), it is good practice
            to clean these up when done. Note, not terminating at this point will usually have no
            ill effect - only Python 3+ on Windows had problems in this regard.
        """
        self.terminate()

    def create_app(self, visible, args):
        if os.name == "nt":
            if visible:
                return Wc3270App(args)
            return Ws3270App(args)
        if visible:
            return X3270App(args)
        return S3270App(args)

    def exec_command(self, cmdstr):
        """
            Execute an x3270 command

            `cmdstr` gets sent directly to the x3270 subprocess on it's stdin.
        """
        if self.is_terminated:
            raise TerminatedError("this TerminalClient instance has been terminated")

        log.debug("sending command: %s", cmdstr)
        print(cmdstr)
        c = Command(self.app, cmdstr)
        start = time.time()
        c.execute()
        elapsed = time.time() - start
        log.debug("elapsed execution: {0}".format(elapsed))
        self.status = Status(c.status_line)

        return c

    def terminate(self):
        """
            terminates the underlying x3270 subprocess. Once called, this
            Emulator instance must no longer be used.
        """
        if not self.is_terminated:
            log.debug("terminal client terminated")
            try:
                self.exec_command(b"Quit")
            except BrokenPipeError:  # noqa
                # x3270 was terminated, since we are just quitting anyway, ignore it.
                pass
            except socket.error as e:
                if e.errno != errno.ECONNRESET:
                    raise
                # this can happen because wc3270 closes the socket before
                # the read() can happen, causing a socket error

            self.app.close()

            self.is_terminated = True

    def is_connected(self):
        """
            Return bool indicating connection state
        """
        # need to wrap in try/except b/c of wc3270's socket connection dynamics
        try:
            # this is basically a no-op, but it results in the the current status
            # getting updated
            self.exec_command(b"Query(ConnectionState)")

            # connected status is like 'C(192.168.1.1)', disconnected is 'N'
            return self.status.connection_state.startswith(b"C(")
        except NotConnectedException:
            return False

    def connect(self, host):
        """
            Connect to a host
        """
        if not self.app.connect(host):
            command = "Connect({0})".format(host).encode("ascii")
            self.exec_command(command)
        self.last_host = host

    def reconnect(self):
        """
            Disconnect from the host and re-connect to the same host
        """
        self.exec_command(b"Disconnect")
        self.connect(self.last_host)

    def wait_for_field(self):
        """
            Wait until the screen is ready, the cursor has been positioned
            on a modifiable field, and the keyboard is unlocked.

            Sometimes the server will "unlock" the keyboard but the screen will
            not yet be ready.  In that case, an attempt to read or write to the
            screen will result in a 'E' keyboard status because we tried to
            read from a screen that is not yet ready.

            Using this method tells the client to wait until a field is
            detected and the cursor has been positioned on it.
        """
        self.exec_command("Wait({0}, InputField)".format(self.timeout).encode("ascii"))
        if self.status.keyboard != b"U":
            raise KeyboardStateError(
                "keyboard not unlocked, state was: {0}".format(
                    self.status.keyboard.decode("ascii")
                )
            )

    def move_to(self, ypos, xpos):
        """
            move the cursor to the given co-ordinates.  Co-ordinates are 1
            based, as listed in the status area of the terminal.
        """
        # the screen's co-ordinates are 1 based, but the command is 0 based
        xpos -= 1
        ypos -= 1
        self.exec_command("MoveCursor({0}, {1})".format(ypos, xpos).encode("ascii"))

    def send_string(self, tosend, ypos=None, xpos=None):
        """
            Send a string to the screen at the current cursor location or at
            screen co-ordinates `ypos`/`xpos` if they are both given.

            Co-ordinates are 1 based, as listed in the status area of the
            terminal.
        """
        if xpos is not None and ypos is not None:
            self.move_to(ypos, xpos)

        # escape double quotes in the data to send
        tosend = tosend.replace('"', '"')
        print(tosend)

        self.exec_command('String("{0}")'.format(tosend).encode("ascii"))

    def send_transaction(self, txn_code):
    # Clear the screen first
        self.exec_command(b"Clear")

          # Move to top-left corner (row 1, column 1)
        self.move_to(1, 1)

        # Send the transaction code
        self.exec_command(f'String("{txn_code}")'.encode("ascii"))

        # Press Enter to execute the transaction
        self.exec_command(b"Enter")

    def send_enter(self):
        self.exec_command(b"Enter")

    def send_pf3(self):
        self.exec_command(b"PF(3)")

    def send_pf2(self):
        self.exec_command(b"PF(2)")


    def send_pf4(self):
        self.exec_command(b"PF(4)")

    def send_pf5(self):
        self.exec_command(b"PF(5)")

    def send_pf6(self):
        self.exec_command(b"PF(6)")

    def send_pf7(self):
        self.exec_command(b"PF(7)")

    def send_pf8(self):
        self.exec_command(b"PF(8)")

    def send_tab(self):
        self.exec_command(b"TAB")

    def send_clear(self):
        self.exec_command(b"Clear")

    def send_pf(self, value):
        pf = "PF({})".format(value)
        self.exec_command(bytes(pf.encode("utf-8")))

    def string_get(self, ypos, xpos, length):
        """
            Get a string of `length` at screen co-ordinates `ypos`/`xpos`

            Co-ordinates are 1 based, as listed in the status area of the
            terminal.
        """
        # the screen's co-ordinates are 1 based, but the command is 0 based
        xpos -= 1
        ypos -= 1
        cmd = self.exec_command(
            "Ascii({0},{1},{2})".format(ypos, xpos, length).encode("ascii")
        )
        # this usage of ascii should only return a single line of data
        assert len(cmd.data) == 1, cmd.data
        return cmd.data[0].decode("ascii")

    def string_found(self, ypos, xpos, string):
        """
            Return True if `string` is found at screen co-ordinates
            `ypos`/`xpos`, False otherwise.

            Co-ordinates are 1 based, as listed in the status area of the
            terminal.
        """
        found = self.string_get(ypos, xpos, len(string))
        log.debug('string_found() saw "{0}"'.format(found))
        return found == string

    def delete_field(self):
        """
            Delete contents in field at current cursor location and positions
            cursor at beginning of field.
        """
        self.exec_command(b"DeleteField")

    def fill_field(self, ypos, xpos, tosend, length):
        """
            clears the field at the position given and inserts the string
            `tosend`

            tosend: the string to insert
            length: the length of the field

            Co-ordinates are 1 based, as listed in the status area of the
            terminal.

            raises: FieldTruncateError if `tosend` is longer than
                `length`.
        """
        if length < len(tosend):
            raise FieldTruncateError('length limit %d, but got "%s"' % (length, tosend))
        if xpos is not None and ypos is not None:
            self.move_to(ypos, xpos)
        self.delete_field()
        self.send_string(tosend)

    def save_screen(self, file_path):
        self.exec_command("PrintText(html,file,{0})".format(file_path).encode("ascii"))

