import base64
import getpass
from emu3270 import MFRobot
import time
import os
import pandas as pd
import datetime
import re
import json
import numpy as np

# --- Helper Function to Parse Date from Filename ---
def get_refund_date_from_filename(path):
    match = re.search(r'(\d{2}[a-zA-Z]{3}\d{4})', path)
    if not match:
        print(f"FATAL ERROR: Could not find a date (e.g., 07jul2025) in the filename: {path}")
        exit()
    date_str = match.group(1).upper()
    try:
        return datetime.datetime.strptime(date_str, "%d%b%Y")
    except ValueError as e:
        print(f"FATAL ERROR: Matched string '{date_str}' from filename, but could not parse it as a date. {e}")
        exit()

# --- Data Preparation Function ---
def structure_account_data(excel_path):
    df = pd.read_excel(excel_path)
    if 'Charges' not in df.columns:
        print("FATAL ERROR: 'Charges' column not found in Excel file.")
        exit()
    df['Charges'] = df['Charges'].astype(str)
    df_chargeable = df[df['Charges'].str.strip().str.upper() == 'YES'].copy()
    if df_chargeable.empty:
        print("No rows found with 'Charges' set to 'Yes'.")
        return {}
    df_chargeable['Hit Date DT'] = pd.to_datetime(df_chargeable['Hit Date'], format='%d%b%y')
    structured_data = {}
    for account_number, group_df in df_chargeable.groupby('Account'):
        oldest_row = group_df.loc[group_df['Hit Date DT'].idxmin()]
        base_info = oldest_row.to_dict()
        transactions_df = group_df[['Amount', 'Hit Date']]
        transactions = transactions_df.to_dict(orient='records')
        structured_data[account_number] = {
            'base_info': base_info,
            'transactions': transactions
        }
    return structured_data

# --- Mainframe Functions ---
def goto_masterIndex(brand, switch_brand=False):
    if mf.wait_for_text("MASTER INDEX") and not switch_brand:
        return
    while not mf.wait_for_text("APPLICATION SELECTION"):
        mf.send_pf2()
        mf.send_pf3() 
    mf.wait_for_text("APPLICATION SELECTION")
    brand_map = {"NWB": (12, 11), "RBS": (13, 11), "UBN": (14, 11)}
    row, col = brand_map.get(brand.upper(), (15, 11))
    mf.move_to(row, col)
    mf.send_string("s")
    mf.send_enter()
    mf.wait_for_text("Option Handler Function Screen")
    mf.send_string("19")
    mf.send_enter()
    mf.wait_for_text("BACK OFFICE SYSTEM")
    mf.send_string("1")
    mf.send_enter()
    mf.wait_for_text("MASTER INDEX")

def check_limit(sort_code, account_number):
    mf.wait_for_text("MASTER INDEX")
    mf.move_to(22, 8)
    mf.send_string("20")
    mf.move_to(22, 74)
    mf.send_string(f"{sort_code:06d}")
    mf.send_enter()
    mf.wait_for_text("FILE MAINTENANCE INPUT INDEX")
    mf.send_string("01")
    mf.send_string(f"{account_number:08d}")
    mf.send_enter()
    mf.wait_for_text("CUSTOMER INFORMATION INDEX") 
    mf.send_enter()
    mf.wait_for_text("BALANCE ENQUIRY")
    limit = mf.string_get(6, 58, 10).strip()
    return float(limit.replace(',', '')) if limit and not limit.isalpha() else 0.0

def extract_unpaid_data_from_page():
    page_data = {"transactions": {}}
    mf.move_to(22, 45)
    mf.send_string("u")
    mf.send_enter()
    try: mf.wait_for_field()
    except Exception: return page_data
    screen_text = mf.get_screen_text()
    if "UNPAID ITEMS HISTORY" not in screen_text:
        return page_data
    for i in range(3):
        try:
            if i > 0:
                mf.wait_for_field()
                screen_text = mf.get_screen_text()
            if "accrued_charge" not in page_data:
                accrued_match = re.search(r"ACCRUED CHARGE\s*:\s*([\d,.]+|N/A)", screen_text)
                applied_match = re.search(r"APPLIED CHARGE\s*:\s*([\d,.]+|N/A)", screen_text)
                if accrued_match:
                    value_str = accrued_match.group(1).strip()
                    page_data["accrued_charge"] = float(value_str.replace(',', '')) if value_str.upper() != 'N/A' else 'N/A'
                if applied_match:
                    value_str = applied_match.group(1).strip()
                    page_data["applied_charge"] = float(value_str.replace(',', '')) if value_str.upper() != 'N/A' else 'N/A'
            unpaid_matches = re.findall(r"^\s*(\d{2}[A-Z]{3}\d{2}).*\*.*?([\d,.]+)\s*$", screen_text, re.MULTILINE)
            for date_str, amount_str in unpaid_matches:
                page_data["transactions"][date_str] = {"amount": float(amount_str.replace(',', ''))}
            page_match = re.search(r"PAGE\s+(\d+)\s+OF\s+(\d+)", screen_text)
            if page_match and int(page_match.group(1)) < int(page_match.group(2)):
                mf.send_pf8()
                mf.wait_for_field() 
            else: break
        except Exception: break
    mf.send_pf2()
    mf.wait_for_field()
    return page_data

def process_account_history(hit_date_dt, refund_date_dt):
    mf.wait_for_text("BALANCE ENQUIRY")
    mf.move_to(22, 8)
    mf.send_string("13")
    mf.send_enter()
    mf.wait_for_text("SERVICE CHARGE ENQUIRY INDEX") 
    mf.move_to(22, 9)
    mf.send_string("01")
    mf.send_enter()
    mf.wait_for_field()
    screen_text = mf.get_screen_text()

    if "ACCOUNT IS NON-CHARGEABLE" in screen_text or "SERVICE CHARGE HISTORY" not in screen_text:
        # --- MODIFIED: Return to Customer Info Index ---
        while not mf.wait_for_text("CUSTOMER INFORMATION INDEX"): mf.send_pf2()
        return "Non-Chargeable or No History", {}

    all_collected_unpaids = {}
    date_range_found = False
    for _ in range(16):
        current_page_text = mf.get_screen_text()
        if "NO HISTORY DETAILS AVAILABLE" in current_page_text: break 
        if "U-UNPAIDS" in current_page_text:
            page_num_match = re.search(r"PAGE\s+(\d+)", current_page_text)
            page_num = page_num_match.group(1) if page_num_match else "Unknown"
            unpaid_data = extract_unpaid_data_from_page()
            if unpaid_data: all_collected_unpaids[page_num] = unpaid_data
        
        start_date_match = re.search(r"START DATE\s*:\s*(\d{2}[A-Z]{3}\d{2})", current_page_text)
        end_date_match = re.search(r"END DATE\s*:\s*(\d{2}[A-Z]{3}\d{2})", current_page_text)
        if start_date_match and end_date_match:
            screen_start_dt = datetime.datetime.strptime(start_date_match.group(1), "%d%b%y")
            screen_end_dt = datetime.datetime.strptime(end_date_match.group(1), "%d%b%y")
            if screen_start_dt <= hit_date_dt <= screen_end_dt:
                date_range_found = True
                break
        mf.send_pf8()
        mf.wait_for_field()

    final_filtered_data = {}
    if all_collected_unpaids:
        for page, data in all_collected_unpaids.items():
            filtered_transactions = {}
            for trans_date_str, trans_details in data.get("transactions", {}).items():
                trans_dt = datetime.datetime.strptime(trans_date_str, "%d%b%y")
                if hit_date_dt < trans_dt < refund_date_dt:
                    filtered_transactions[trans_date_str] = trans_details
            if filtered_transactions:
                final_filtered_data[page] = { "accrued_charge": data.get("accrued_charge"), "applied_charge": data.get("applied_charge"), "transactions": filtered_transactions }
    
    # --- MODIFIED: Return to Customer Info Index ---
    while not mf.wait_for_text("CUSTOMER INFORMATION INDEX"): mf.send_pf2()
    status = "Success"
    if not date_range_found: status = "Error: Hit Date Range Not Found"
    elif not final_filtered_data: status = "Success: No Qualifying Unpaids"
    return status, final_filtered_data

# --- NEW FUNCTION TO GET CLOSING BALANCES ---
def get_closing_balances(unpaid_data_dict):
    """
    Starts from CUSTOMER INFORMATION INDEX, finds closing balances for each unpaid
    transaction, enriches the dictionary, and returns to MASTER INDEX.
    """
    mf.wait_for_text("CUSTOMER INFORMATION INDEX")
    mf.move_to(22, 8)
    mf.send_string("09") # Option for ACCOUNT HISTORY
    mf.send_enter()
    mf.wait_for_text("ACCOUNT HISTORY ENQUIRY")
    mf.send_enter() # Proceed with default options
    
    # This will land us on the Transaction History screen, ready to search
    mf.wait_for_text("TRANSACTION HISTORY")
    
    # Iterate through all pages and transactions in the dictionary
    for page_num, page_data in unpaid_data_dict.items():
        for date_str, trans_details in page_data.get("transactions", {}).items():
            try:
                print(f"  -> Searching balance for transaction date: {date_str}")
                mf.move_to(22, 56) # Position for start date
                mf.send_string(date_str) # Send date like "11JUN25"
                mf.send_enter()
                mf.send_pf8() # Search backwards
                mf.wait_for_field()

                # Upward scrape logic
                balance_found = None
                for row_num in range(20, 5, -1): # Search from row 20 up to row 6
                    balance_text = mf.string_get(row_num, 67, 14).strip()
                    if balance_text:
                        if "DR" in balance_text.upper():
                            balance_found = -1 * float(balance_text.upper().replace("DR", "").strip())
                        else:
                            balance_found = float(balance_text.strip())
                        break # Exit the upward scrape loop once a balance is found
                
                # Add the found balance back into the dictionary
                trans_details['closing_balance'] = balance_found
                
            except Exception as e:
                print(f"    -> WARNING: Could not get balance for {date_str}. Error: {e}")
                trans_details['closing_balance'] = 'Error'

    # After processing all unpaids, return to the master index for the next account
    while not mf.wait_for_text("MASTER INDEX"): mf.send_pf2()
        
    return unpaid_data_dict


# --- JSON HELPER ---
def convert_numpy_types(obj):
    if isinstance(obj, (np.integer, np.int64)): return int(obj)
    elif isinstance(obj, (np.floating, np.float64)): return float(obj)
    elif isinstance(obj, np.ndarray): return obj.tolist()
    elif isinstance(obj, pd.Timestamp): return obj.isoformat()
    return obj

# --- SCRIPT EXECUTION ---
excel_file_path = r"Z:\Business Unit Team Management\Chargebacks\8. Interest & Charges (Chargebacks) (LD1700 Active+6 years)-Classification Internal & Confidential\Chennai\3.0 India\4. Work Allocation\2025\DRS Manual files\July\08072025\07jul2025_part4_srini.xlsx"

print("--- Phase 1: Preparing account data from Excel ---")
account_data = structure_account_data(excel_file_path)
if not account_data:
    print("No chargeable accounts to process. Exiting.")
    exit()
print(f"Found {len(account_data)} unique chargeable accounts to process.")

print("\n--- Phase 2: Starting Mainframe Processing ---")
mf = MFRobot(visible=True)
mf.connect_n_login(racf='raosx', password='pooja016')
refund_date = get_refund_date_from_filename(excel_file_path)
print(f"Extracted Refund Date: {refund_date.strftime('%d-%b-%Y')}")

previous_brand = None
for i, (account_number, data) in enumerate(account_data.items()):
    try:
        base_info = data['base_info']
        current_brand = base_info['Brand']
        print(f"\nProcessing account {i+1}/{len(account_data)}: {account_number} ({current_brand})...")

        if current_brand != previous_brand:
            print(f"Changing brand to {current_brand}")
            goto_masterIndex(current_brand, switch_brand=True)
        
        limit_found = check_limit(base_info['Sort Code'], base_info['Account'])
        status, unpaids_found = process_account_history(base_info['Hit Date DT'], refund_date)

        # NEW: Check for unpaids and get closing balances if they exist
        if unpaids_found:
            enriched_unpaids = get_closing_balances(unpaids_found)
            data['mainframe_unpaids'] = enriched_unpaids
        else:
            data['mainframe_unpaids'] = unpaids_found # Store the empty dict

        data['limit'] = limit_found
        data['mainframe_status'] = status
        
        previous_brand = current_brand
        print(f"Status for account {account_number}: {status}")

    except Exception as e:
        print(f"CRITICAL ERROR on account {account_number}: {e}")
        data['mainframe_status'] = f"Error: {e}"
        if "TerminalClient instance has been terminated" in str(e):
            print("Connection lost. Attempting to reconnect...")
            try: mf.terminate()
            except: pass
            mf = MFRobot(visible=True)
            mf.connect_n_login(racf='raosx', password='pooja016')
            previous_brand = None
        else:
            print("This was a data processing error, not a connection error. Continuing...")
            continue

# --- Phase 3: Generating Final Report ---
print("\n--- Phase 3: Generating Final Account-Wise Report ---")
output_rows = []
for account_number, data in account_data.items():
    base_info = data.get('base_info', {})
    row_data = {
        'Case Number': base_info.get('Case Number'),
        'Sort Code': base_info.get('Sort Code'),
        'Account': base_info.get('Account'),
        'Brand': base_info.get('Brand'),
        'Limit': data.get('limit'),
        'Processing Status': data.get('mainframe_status'),
        'Basic Info': json.dumps(base_info, indent=4, default=convert_numpy_types),
        'Transaction Data': json.dumps(data.get('transactions'), indent=4, default=convert_numpy_types),
        'Unpaid Data': json.dumps(data.get('mainframe_unpaids'), indent=4, default=convert_numpy_types)
    }
    output_rows.append(row_data)

output_df = pd.DataFrame(output_rows)
final_column_order = [
    'Case Number', 'Sort Code', 'Account', 'Brand', 'Processing Status', 'Limit',
    'Basic Info', 'Transaction Data', 'Unpaid Data'
]
existing_cols = [col for col in final_column_order if col in output_df.columns]
output_df = output_df[existing_cols]
output_df.to_excel(r"C:\Users\raosx\Downloads\limit_output_final_structured.xlsx", index=False)

print("\nScript finished successfully.")
if mf: mf.terminate()
