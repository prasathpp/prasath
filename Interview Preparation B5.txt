def extract_unpaid_data_from_page(source_page_number):
    """Drills down into 'U-UNPAIDS', scrapes all pages of transactions, and returns."""
    page_data = {"transactions": {}}
    mf.move_to(22, 45)
    mf.send_string("u")
    mf.send_enter()

    for _ in range(3):
        mf.wait_for_text("UNPAID ITEMS HISTORY")
        screen_text = mf.get_screen_text()

        if "accrued_charge" not in page_data:
            accrued_match = re.search(r"ACCRUED CHARGE\s*:\s*([\d,.]+)", screen_text)
            applied_match = re.search(r"APPLIED CHARGE\s*:\s*([\d,.]+)", screen_text)
            if accrued_match: page_data["accrued_charge"] = float(accrued_match.group(1).replace(',', ''))
            if applied_match: page_data["applied_charge"] = float(applied_match.group(1).replace(',', ''))

        # --- THIS IS THE CORRECTED REGEX ---
        unpaid_matches = re.findall(r"^(\d{2}[A-Z]{3}\d{2}).*? \* .*?([\d,.]+)$", screen_text, re.MULTILINE)
        
        for date_str, amount_str in unpaid_matches:
            amount = float(amount_str.replace(',', ''))
            page_data["transactions"][date_str] = {"amount": amount}

        page_match = re.search(r"PAGE\s+(\d+)\s+OF\s+(\d+)", screen_text)
        if page_match:
            current_page = int(page_match.group(1))
            total_pages = int(page_match.group(2))
            if current_page >= total_pages:
                break # Last page, exit loop
        else:
            # If "PAGE X OF Y" is not found, assume it's a single page and exit.
            break 
        
        mf.send_pf8()
        time.sleep(0.5)

    mf.send_pf2()
    mf.wait_for_text("SERVICE CHARGE HISTORY")
    return page_data
