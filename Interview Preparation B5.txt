import base64
import getpass
from emu3270 import MFRobot
import time
import os
import pandas as pd
import datetime
import re
import json
import numpy as np
import copy

# --- Helper Function to Parse Date from Filename ---
def get_refund_date_from_filename(path):
    match = re.search(r'(\d{2}[a-zA-Z]{3}\d{4})', path)
    if not match:
        print(f"FATAL ERROR: Could not find a date (e.g., 07jul2025) in the filename: {path}")
        exit()
    date_str = match.group(1).upper()
    try:
        return datetime.datetime.strptime(date_str, "%d%b%Y")
    except ValueError as e:
        print(f"FATAL ERROR: Matched string '{date_str}' from filename, but could not parse it as a date. {e}")
        exit()

# --- Data Preparation Function ---
def structure_account_data(excel_path):
    df = pd.read_excel(excel_path)
    if 'Charges' not in df.columns:
        print("FATAL ERROR: 'Charges' column not found in Excel file.")
        exit()
    df['Charges'] = df['Charges'].astype(str)
    df_chargeable = df[df['Charges'].str.strip().str.upper() == 'YES'].copy()
    if df_chargeable.empty:
        print("No rows found with 'Charges' set to 'Yes'.")
        return {}
    df_chargeable['Hit Date DT'] = pd.to_datetime(df_chargeable['Hit Date'], format='%d%b%y')
    structured_data = {}
    for account_number, group_df in df_chargeable.groupby('Account'):
        oldest_row = group_df.loc[group_df['Hit Date DT'].idxmin()]
        base_info = oldest_row.to_dict()
        transactions_df = group_df[['Amount', 'Hit Date']]
        transactions = transactions_df.to_dict(orient='records')
        structured_data[account_number] = {
            'base_info': base_info,
            'transactions': transactions
        }
    return structured_data

# --- Mainframe Functions ---
def goto_masterIndex(brand, switch_brand=False):
    if mf.wait_for_text("MASTER INDEX") and not switch_brand:
        return
    while not mf.wait_for_text("APPLICATION SELECTION"):
        mf.send_pf2()
        mf.send_pf3() 
    mf.wait_for_text("APPLICATION SELECTION")
    brand_map = {"NWB": (12, 11), "RBS": (13, 11), "UBN": (14, 11)}
    row, col = brand_map.get(brand.upper(), (15, 11))
    mf.move_to(row, col)
    # --- FIX: Corrected navigation logic ---
    mf.send_string("s")
    mf.send_enter()
    mf.wait_for_text("Option Handler Function Screen")
    mf.send_string("19")
    mf.send_enter()
    mf.wait_for_text("BACK OFFICE SYSTEM")
    mf.send_string("1")
    mf.send_enter()
    mf.wait_for_text("MASTER INDEX")

def check_limit(sort_code, account_number):
    mf.wait_for_text("MASTER INDEX")
    mf.move_to(22, 8)
    mf.send_string("20")
    mf.move_to(22, 74)
    mf.send_string(f"{sort_code:06d}")
    mf.send_enter()
    mf.wait_for_field()
    screen_text = mf.get_screen_text()
    if "ACCOUNT NOT ON FILE" in screen_text:
        print("  -> Info: Account not on file.")
        while not mf.wait_for_text("MASTER INDEX"): mf.send_pf2()
        return "Account Not On File", None
    mf.wait_for_text("FILE MAINTENANCE INPUT INDEX")
    mf.send_string("01")
    mf.send_string(f"{account_number:08d}")
    mf.send_enter()
    mf.wait_for_text("CUSTOMER INFORMATION INDEX") 
    mf.send_enter()
    mf.wait_for_text("BALANCE ENQUIRY")
    limit = mf.string_get(6, 58, 10).strip()
    return "Success", float(limit.replace(',', '')) if limit and not limit.isalpha() else 0.0

def extract_unpaid_data_from_page():
    page_data = {"transactions": {}}
    mf.move_to(22, 45)
    mf.send_string("u")
    mf.send_enter()
    try: mf.wait_for_field()
    except Exception: return page_data
    screen_text = mf.get_screen_text()
    if "UNPAID ITEMS HISTORY" not in screen_text: return page_data
    for i in range(3):
        try:
            if i > 0: mf.wait_for_field(); screen_text = mf.get_screen_text()
            if "accrued_charge" not in page_data:
                accrued_match = re.search(r"ACCRUED CHARGE\s*:\s*([\d,.]+|N/A)", screen_text)
                applied_match = re.search(r"APPLIED CHARGE\s*:\s*([\d,.]+|N/A)", screen_text)
                if accrued_match: page_data["accrued_charge"] = float(accrued_match.group(1).strip().replace(',', '')) if accrued_match.group(1).strip().upper() != 'N/A' else 'N/A'
                if applied_match: page_data["applied_charge"] = float(applied_match.group(1).strip().replace(',', '')) if applied_match.group(1).strip().upper() != 'N/A' else 'N/A'
            unpaid_matches = re.findall(r"^\s*(\d{2}[A-Z]{3}\d{2}).*\*.*?([\d,.]+)\s*$", screen_text, re.MULTILINE)
            for date_str, amount_str in unpaid_matches: page_data["transactions"][date_str] = {"amount": float(amount_str.replace(',', ''))}
            page_match = re.search(r"PAGE\s+(\d+)\s+OF\s+(\d+)", screen_text)
            if page_match and int(page_match.group(1)) < int(page_match.group(2)): mf.send_pf8(); mf.wait_for_field() 
            else: break
        except Exception: break
    mf.send_pf2(); mf.wait_for_field()
    return page_data

def process_minimum_service_charge():
    mf.move_to(22, 45); mf.send_string("z"); mf.send_enter()
    try: mf.wait_for_field()
    except Exception: mf.send_pf2(); mf.wait_for_field(); return None
    
    screen_text = mf.get_screen_text()
    if "HISTORY ITEM DETAILS" not in screen_text:
        mf.send_pf2(); mf.wait_for_field()
        return None
    
    # --- FIX: Corrected typo from d_match to dbs_match ---
    dbs_match = re.search(r"^\s*OTHER AUTOMATED DBS\s+([\d.]+)\s+(\d+)", screen_text, re.MULTILINE)
    mf.send_pf2(); mf.wait_for_field()
    
    if dbs_match:
        return {"rate": float(dbs_match.group(1)), "count": int(dbs_match.group(2))}
    return None

def process_account_history(hit_date_dt, refund_date_dt):
    mf.wait_for_text("BALANCE ENQUIRY")
    mf.move_to(22, 8); mf.send_string("13"); mf.send_enter()
    mf.wait_for_text("SERVICE CHARGE ENQUIRY INDEX") 
    mf.move_to(22, 9); mf.send_string("01"); mf.send_enter()
    mf.wait_for_field()
    screen_text = mf.get_screen_text()
    if "ACCOUNT IS NON-CHARGEABLE" in screen_text or "SERVICE CHARGE HISTORY" not in screen_text:
        while not mf.wait_for_text("CUSTOMER INFORMATION INDEX"): mf.send_pf2()
        return "Non-Chargeable or No History", {}

    history_data = {"unpaids": {}, "msc": {}}
    date_range_found = False
    for _ in range(16):
        current_page_text = mf.get_screen_text()
        if "NO HISTORY DETAILS AVAILABLE" in current_page_text: break 
        
        page_num_match = re.search(r"PAGE\s+(\d+)", current_page_text)
        page_num = page_num_match.group(1) if page_num_match else "Unknown"
        
        start_date_match = re.search(r"START DATE\s*:\s*(\d{2}[A-Z]{3}\d{2})", current_page_text)
        end_date_match = re.search(r"END DATE\s*:\s*(\d{2}[A-Z]{3}\d{2})", current_page_text)
        
        if page_num == "1":
            if end_date_match: history_data['page_1_end_date'] = end_date_match.group(1)
            
        if "U-UNPAIDS" in current_page_text:
            unpaid_data = extract_unpaid_data_from_page()
            if unpaid_data and unpaid_data.get("transactions"):
                history_data["unpaids"][page_num] = unpaid_data
        
        if "MINIMUM SERVICE CHARGE" in current_page_text:
            if start_date_match and end_date_match:
                msc_data = process_minimum_service_charge()
                if msc_data:
                    msc_data['start_date'] = start_date_match.group(1)
                    msc_data['end_date'] = end_date_match.group(1)
                    history_data["msc"][page_num] = msc_data
        
        if start_date_match and end_date_match and not date_range_found:
            screen_start_dt = datetime.datetime.strptime(start_date_match.group(1), "%d%b%y")
            screen_end_dt = datetime.datetime.strptime(end_date_match.group(1), "%d%b%y")
            if screen_start_dt <= hit_date_dt <= screen_end_dt:
                date_range_found = True
                break
        
        mf.send_pf8()
        mf.wait_for_field()
    
    while not mf.wait_for_text("CUSTOMER INFORMATION INDEX"): mf.send_pf2()
    status = "Success"
    if not date_range_found: status = "Error: Hit Date Range Not Found"
    elif not history_data.get("unpaids") and not history_data.get("msc"): status = "Success: No Qualifying Data"
    return status, history_data

def get_closing_balances(unpaid_data_dict):
    data_copy = copy.deepcopy(unpaid_data_dict)
    mf.wait_for_text("CUSTOMER INFORMATION INDEX")
    mf.move_to(22, 8); mf.send_string("48"); mf.send_enter()
    mf.wait_for_text("TRANSACTION HISTORY")
    for page_num, page_data in data_copy.items():
        if not isinstance(page_data, dict): continue
        for date_str, trans_details in page_data.get("transactions", {}).items():
            try:
                print(f"  -> Searching balance for transaction date: {date_str}")
                mf.move_to(22, 56); mf.send_string(date_str); mf.send_enter()
                mf.send_pf8(); mf.wait_for_field()
                balance_found = None
                for row_num in range(20, 5, -1):
                    balance_text = mf.string_get(row_num, 67, 14).strip()
                    if balance_text:
                        is_debit = "DR" in balance_text.upper()
                        numeric_part = balance_text.upper().replace("DR", "").replace(",", "").strip()
                        balance_value = float(numeric_part)
                        balance_found = -balance_value if is_debit else balance_value
                        break
                trans_details['closing_balance'] = balance_found
            except Exception as e:
                print(f"    -> WARNING: Could not get balance for {date_str}. Error: {e}")
                trans_details['closing_balance'] = 'Error'
    while not mf.wait_for_text("MASTER INDEX"): mf.send_pf2()
    return data_copy

def calculate_refunds(account_data):
    limit_amount = account_data.get('limit', 0)
    history_data = account_data.get('history_data', {})
    dispute_transactions = account_data.get('transactions', [])
    unpaid_diary, unpaid_replace, unpaid_manual = 0.0, 0.0, 0.0
    msc_diary, msc_replace, msc_manual = 0.0, 0.0, 0.0
    
    unpaid_data_to_process = copy.deepcopy(history_data.get('unpaids', {}))
    valid_unpaids = []
    page_1_end_date_str = unpaid_data_to_process.pop('page_1_end_date', None)
    for page_num, page_data in unpaid_data_to_process.items():
        if not isinstance(page_data, dict): continue
        applied_charge = page_data.get('applied_charge', 0)
        if applied_charge is None or applied_charge == 'N/A' or applied_charge == 0: continue
        transactions = page_data.get("transactions", {})
        num_trans = len(transactions)
        if num_trans == 0: continue
        individual_charge = (page_data.get('accrued_charge', 0) / num_trans)
        for date_str, details in transactions.items():
            if details.get('closing_balance') == 'Error': continue
            details.update({
                'date_dt': datetime.datetime.strptime(date_str, "%d%b%y"),
                'individual_charge': individual_charge,
                'source_page': int(page_num)
            })
            valid_unpaids.append(details)
    
    if valid_unpaids:
        valid_unpaids.sort(key=lambda x: x['date_dt'])
        disputes = sorted([{'amount': d['Amount'], 'date_dt': datetime.datetime.strptime(d['Hit Date'], "%d%b%y")} for d in dispute_transactions], key=lambda x: x['date_dt'])
        remainingBalance = 0.0
        utilized_disputes = []
        for unpaid in valid_unpaids:
            decision = "No"; closing_balance = unpaid.get('closing_balance', 0); unpaid_amount = unpaid.get('amount', 0)
            if closing_balance >= unpaid_amount or (closing_balance + limit_amount) >= unpaid_amount: decision = "No"
            elif (closing_balance + limit_amount + remainingBalance) >= unpaid_amount:
                decision = "Yes"; remainingBalance = (closing_balance + limit_amount + remainingBalance) - unpaid_amount
            else:
                relevant_disputes = [d for d in disputes if d['date_dt'] < unpaid['date_dt'] and d not in utilized_disputes]
                totalDisputedAmount = sum(d['amount'] for d in relevant_disputes)
                if (closing_balance + limit_amount + remainingBalance + totalDisputedAmount) >= unpaid_amount:
                    decision = "Yes"; remainingBalance = (closing_balance + limit_amount + remainingBalance + totalDisputedAmount) - unpaid_amount; utilized_disputes.extend(relevant_disputes)
                else:
                    decision = "No"; remainingBalance = (closing_balance + limit_amount + remainingBalance + totalDisputedAmount)
            if decision == "Yes":
                if unpaid['source_page'] == 1: unpaid_diary += unpaid['individual_charge']
                elif unpaid['source_page'] == 2: unpaid_replace += unpaid['individual_charge']
                else: unpaid_manual += unpaid['individual_charge']

    msc_data = history_data.get('msc', {})
    for page_num, data in msc_data.items():
        start_dt = datetime.datetime.strptime(data['start_date'], "%d%b%y"); end_dt = datetime.datetime.strptime(data['end_date'], "%d%b%y")
        scraped_count = data['count']; scraped_rate = data['rate']
        disputes_in_period = [d for d in dispute_transactions if start_dt <= datetime.datetime.strptime(d['Hit Date'], "%d%b%y") <= end_dt]
        if scraped_count >= len(disputes_in_period):
            refund_amount = len(disputes_in_period) * scraped_rate
            if int(page_num) == 1: msc_diary += refund_amount
            elif int(page_num) == 2: msc_replace += refund_amount
            else: msc_manual += refund_amount
    
    diary_date = ""
    if (unpaid_diary > 0 or msc_diary > 0) and page_1_end_date_str:
        end_date = datetime.datetime.strptime(page_1_end_date_str, "%d%b%y")
        next_day = end_date + datetime.timedelta(days=1)
        while next_day.weekday() >= 5: next_day += datetime.timedelta(days=1)
        diary_date = next_day.strftime("%d-%b-%Y")

    return unpaid_diary, unpaid_replace, unpaid_manual, msc_diary, msc_replace, msc_manual, diary_date

# --- JSON HELPER ---
def convert_numpy_types(obj):
    if isinstance(obj, (np.integer, np.int64)): return int(obj)
    elif isinstance(obj, (np.floating, np.float64)): return float(obj)
    elif isinstance(obj, np.ndarray): return obj.tolist()
    elif isinstance(obj, pd.Timestamp): return obj.isoformat()
    return obj

# --- SCRIPT EXECUTION ---
excel_file_path = r"Z:\Business Unit Team Management\Chargebacks\8. Interest & Charges (Chargebacks) (LD1700 Active+6 years)-Classification Internal & Confidential\Chennai\3.0 India\4. Work Allocation\2025\DRS Manual files\July\08072025\07jul2025_part4_srini.xlsx"
print("--- Phase 1: Preparing account data from Excel ---")
account_data = structure_account_data(excel_file_path)
if not account_data:
    print("No chargeable accounts to process. Exiting.")
    exit()
print(f"Found {len(account_data)} unique chargeable accounts to process.")
refund_date = get_refund_date_from_filename(excel_file_path)
print(f"Extracted Refund Date: {refund_date.strftime('%d-%b-%Y')}")
# --- REGRESSION FIX: Added back environment variable setup ---
wc3270 = ';W:\\;'
path_var = os.environ.get('Path', '')
if wc3270 not in path_var:
    os.environ["Path"] = path_var + wc3270
    print("wc3270 path added to environment.")
else:
    print("wc3270 path already exists.")

print("\n--- Phase 2: Starting Mainframe Processing & Calculation ---")
mf = MFRobot(visible=True)
mf.connect_n_login(racf='raosx', password='pooja016')
previous_brand = None
for i, (account_number, data) in enumerate(account_data.items()):
    try:
        base_info = data['base_info']
        current_brand = base_info['Brand']
        print(f"\nProcessing account {i+1}/{len(account_data)}: {account_number} ({current_brand})...")
        if current_brand != previous_brand:
            print(f"Changing brand to {current_brand}")
            goto_masterIndex(current_brand, switch_brand=True)
        
        limit_status, limit_found = check_limit(base_info['Sort Code'], base_info['Account'])
        if limit_status == "Account Not On File":
            data['mainframe_status'] = limit_status; continue

        status, history_found = process_account_history(base_info['Hit Date DT'], refund_date)
        data['limit'] = limit_found
        data['mainframe_status'] = status
        data['history_data'] = history_found
        
        if history_found.get("unpaids"):
            enriched_unpaids = get_closing_balances(history_found.get("unpaids"))
            history_found["unpaids"] = enriched_unpaids
        
        u_diary, u_replace, u_manual, msc_diary, msc_replace, msc_manual, diary_dt = calculate_refunds(data)
        data.update({
            'unpaid_diary_refund': u_diary, 'unpaid_replace_refund': u_replace, 'unpaid_manual_refund': u_manual,
            'msc_diary_refund': msc_diary, 'msc_replace_refund': msc_replace, 'msc_manual_refund': msc_manual,
            'diary_date': diary_dt
        })
        
        previous_brand = current_brand
        print(f"Status for account {account_number}: {status}")
    except Exception as e:
        print(f"CRITICAL ERROR on account {account_number}: {e}")
        data['mainframe_status'] = f"Error: {e}"
        if "TerminalClient instance has been terminated" in str(e):
            print("Connection lost. Attempting to reconnect..."); 
            try: mf.terminate()
            except: pass
            mf = MFRobot(visible=True); mf.connect_n_login(racf='raosx', password='pooja016'); previous_brand = None
        else:
            print("This was a data processing error, not a connection error. Continuing..."); continue

# --- Phase 3: Generating Final Report ---
print("\n--- Phase 3: Generating Final Account-Wise Report ---")
output_rows = []
for account_number, data in account_data.items():
    base_info = data.get('base_info', {})
    row_data = {
        'Case Number': base_info.get('Case Number'),
        # --- REGRESSION FIX: Added back zfill() formatting ---
        'Sort Code': str(base_info.get('Sort Code', '')).zfill(6),
        'Account': str(base_info.get('Account', '')).zfill(8),
        'Brand': base_info.get('Brand'),
        'Processing Status': data.get('mainframe_status'),
        'Limit': data.get('limit'),
        'Unpaid Diary Refund': data.get('unpaid_diary_refund'),
        'Unpaid Replace Refund': data.get('unpaid_replace_refund'),
        'Unpaid Manual Refund': data.get('unpaid_manual_refund'),
        'MSC Diary Refund': data.get('msc_diary_refund'),
        'MSC Replace Refund': data.get('msc_replace_refund'),
        'MSC Manual Refund': data.get('msc_manual_refund'),
        'Diary Date': data.get('diary_date'),
        'Basic Info': json.dumps(base_info, indent=4, default=convert_numpy_types),
        'Original Transactions': json.dumps(data.get('transactions'), indent=4, default=convert_numpy_types),
        'Collected History Data': json.dumps(data.get('history_data'), indent=4, default=convert_numpy_types)
    }
    output_rows.append(row_data)

output_df = pd.DataFrame(output_rows)
final_column_order = [
    'Case Number', 'Sort Code', 'Account', 'Brand', 'Processing Status', 'Limit',
    'Unpaid Diary Refund', 'Unpaid Replace Refund', 'Unpaid Manual Refund',
    'MSC Diary Refund', 'MSC Replace Refund', 'MSC Manual Refund', 'Diary Date',
    'Basic Info', 'Original Transactions', 'Collected History Data'
]
existing_cols = [col for col in final_column_order if col in output_df.columns]
output_df = output_df[existing_cols]
output_df.to_excel(r"C:\Users\raosx\Downloads\limit_output_final_structured.xlsx", index=False)

print("\nScript finished successfully.")
if mf: mf.terminate()
