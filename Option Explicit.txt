' Attribute VB_Name = "mod_BackOffice_Automation_V1" ' Simplified module name
Option Explicit

' --- Reflection COM Object Declarations ---
' These variables will hold the references to the Reflection objects
' needed to control the host session.
Public objReflectionApp As Object          ' Represents the main Reflection Workspace application
Public objFrame As Object        ' Represents the main window frame containing views
Public objView As Object         ' Represents the specific session view/tab (e.g., the TN3270 session)
Public objTerminal As Object     ' Represents the terminal control within the view
Public objScreen As Object       ' Represents the interactive screen area of the terminal

' --- Constants for this specific automation (Version 1 - Send TERM ALL) ---
' Define the EXACT title of the session window we will look for using GetViewByTitleText.
' *** IMPORTANT: This must match the window title EXACTLY! ***
' Check the window title bar carefully. Example: "Reflection Workspace - [NTS Back Office - Prod.rd3x]"
' Based on previous logs, "NTS Back Office - Prod.rd3x" seems to be the part GetViewByTitleText uses.
Private Const SESSION_TITLE_PART As String = "NTS Back Office - Prod.rd3x"


' Define the text and coordinates for the command line where we type TERM ALL
Private Const CMD_TERM_ALL As String = "TERM ALL"
Private Const COMMAND_LINE_ROW As Long = 21
Private Const COMMAND_LINE_COL As Long = 13

' Define the text and coordinates for the Security Reminder screen (for handling)
Private Const SCREEN_SECURITY_REMINDER As String = "SECURITY REMINDER"
Private Const SECURITY_REMINDER_ROW As Long = 1
Private Const SECURITY_REMINDER_COL As Long = 29
Private Const SECURITY_REMINDER_LEN As Long = 20 ' Length of the text "SECURITY REMINDER"
Private Const SECURITY_REMINDER_INPUT_ROW As Long = 22 ' Row for 'Y' input
Private Const SECURITY_REMINDER_INPUT_COL As Long = 11 ' Col for 'Y' input

' --- Script Title for MsgBoxes / Debugging ---
Private Const SCRIPT_TITLE As String = "Back Office Automation V1"


' --- Main Entry Sub (Version 1) ---
' This is the procedure you will run to perform the first step:
' Connect to Reflection and send "TERM ALL" on the command line.
Sub Main_SendTermAll_V1()
    On Error GoTo ErrorHandler

    Debug.Print "--- Starting " & SCRIPT_TITLE & " - Send TERM ALL ---"

    ' 1. Attempt to connect to the existing Reflection session and get objects
    If ConnectToReflection_V1(SESSION_TITLE_PART) Then
        Debug.Print SCRIPT_TITLE & ": Successfully connected to Reflection session."

        ' Ensure we have the necessary screen object to proceed
        If objScreen Is Nothing Then
            MsgBox "Critical error: Screen object (objScreen) was not set during connection. Cannot proceed.", vbCritical, SCRIPT_TITLE
            GoTo CleanupAndExit
        End If

        ' 2. Send "TERM ALL" to the command line (R21, C13)
        ' The SendText_V1 function will handle waiting for the screen to be ready and sending Transmit.
        Debug.Print SCRIPT_TITLE & ": Sending '" & CMD_TERM_ALL & "' to command line..."
        Call SendText_V1(CMD_TERM_ALL, COMMAND_LINE_ROW, COMMAND_LINE_COL)

        Debug.Print SCRIPT_TITLE & ": '" & CMD_TERM_ALL & "' sent. First step complete."

        ' Confirmation message box (Corrected syntax)
        MsgBox "'" & CMD_TERM_ALL & "' entered successfully on the command line.", vbInformation, SCRIPT_TITLE


    Else
        ' Connection failed - an error message was already shown by ConnectToReflection_V1
        Debug.Print SCRIPT_TITLE & ": Failed to connect to Reflection session. Aborting."
        ' MsgBox already shown by ConnectToReflection_V1
    End If

CleanupAndExit:
    ' 3. Clean up the Reflection objects regardless of success or failure
    Call CleanUpReflectionObjects_V1

    Debug.Print "--- Finished " & SCRIPT_TITLE & " - Send TERM ALL ---"
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during the macro execution
    MsgBox "Error in '" & SCRIPT_TITLE & "':" & vbCrLf & Err.Number & ": " & Err.Description, vbCritical, SCRIPT_TITLE
    Resume CleanupAndExit ' Go to the cleanup section after showing the error

End Sub


' --- Connection Logic (Version 1) ---
' Connects to an existing Reflection Workspace and finds the specified session
' using GetViewByTitleText.
' Returns True if connection and object retrieval is successful, False otherwise.
Private Function ConnectToReflection_V1(ByVal targetSessionExactTitle As String) As Boolean
    On Error GoTo ConnectErrorHandler_V1
    ConnectToReflection_V1 = False ' Assume failure initially

    Debug.Print "Connect_V1: Attempting GetObject(""Reflection Workspace"")..."
    On Error Resume Next ' Temporarily disable error handling for GetObject
    Set objReflectionApp = GetObject("Reflection Workspace")
    If Err.Number <> 0 Or objReflectionApp Is Nothing Then
        Err.Clear ' Clear the "Object not found" error
        Debug.Print "Connect_V1: GetObject(""Reflection Workspace"") FAILED."
        MsgBox "Could not connect to Reflection Workspace." & vbCrLf & _
               "Please ensure Reflection is running and that 'Enable Reflection Automation' is checked in Reflection settings.", vbCritical, SCRIPT_TITLE
        Exit Function ' Exit the function indicating failure
    End If
    Debug.Print "Connect_V1: RApp obtained. TypeName: " & TypeName(objReflectionApp)
    On Error GoTo ConnectErrorHandler_V1 ' Restore error handling

    Debug.Print "Connect_V1: Attempting objReflectionApp.GetObject(""Frame"")..."
    Set objFrame = objReflectionApp.GetObject("Frame")
    If objFrame Is Nothing Then
         Debug.Print "Connect_V1: Frame object is Nothing."
         MsgBox "Could not get the Reflection Frame object.", vbCritical, SCRIPT_TITLE
         Exit Function
    End If
    Debug.Print "Connect_V1: objFrame obtained. TypeName: " & TypeName(objFrame)

    ' Ensure the frame is visible and brought to front (optional but helpful)
    If Not objFrame.Visible Then objFrame.Visible = True
    objFrame.Activate ' Brings the main Reflection Workspace window to front
    Debug.Print "Connect_V1: Frame Visible/Activated."

    ' ** Using GetViewByTitleText as it previously seemed to work for finding the view **
    Debug.Print "Connect_V1: Attempting objFrame.GetViewByTitleText(""" & targetSessionExactTitle & """)..."
    On Error Resume Next ' Allow GetViewByTitleText to fail if title doesn't match
    Set objView = objFrame.GetViewByTitleText(targetSessionExactTitle)
    If Err.Number <> 0 Or objView Is Nothing Then
        Err.Clear ' Clear the "Object not found" error
        Debug.Print "Connect_V1: objFrame.GetViewByTitleText FAILED or returned Nothing."
        MsgBox "Could not find a Reflection session with the EXACT title: '" & targetSessionExactTitle & "'." & vbCrLf & _
               "Please ensure the correct session file is open in Reflection and its window title matches exactly.", vbCritical, SCRIPT_TITLE
        Exit Function ' Exit function if the target view was not found
    End If
    Debug.Print "Connect_V1: objFrame.GetViewByTitleText SUCCEEDED. View Title: '" & objView.TitleText & "'. TypeName(objView): " & TypeName(objView)
    On Error GoTo ConnectErrorHandler_V1 ' Restore error handling

    ' ** Skipping explicit objView.Activate to avoid previous Error 438 **
    Debug.Print "Connect_V1: Skipping objView.Activate to avoid previous Error 438."

    Debug.Print "Connect_V1: Attempting objView.Control..."
    Set objTerminal = objView.Control
    If objTerminal Is Nothing Then
        Debug.Print "Connect_V1: Terminal object is Nothing."
        MsgBox "Could not get the Reflection Terminal control from the found view.", vbCritical, SCRIPT_TITLE
        Exit Function
    End If
    Debug.Print "Connect_V1: objTerminal obtained. TypeName: " & TypeName(objTerminal)

    Debug.Print "Connect_V1: Attempting objTerminal.Screen..."
    Set objScreen = objTerminal.Screen
    If objScreen Is Nothing Then
        Debug.Print "Connect_V1: Screen object is Nothing."
        MsgBox "Could not get the Reflection Screen object from the terminal control.", vbCritical, SCRIPT_TITLE
        Exit Function
    End If
    Debug.Print "Connect_V1: objScreen obtained. TypeName: " & TypeName(objScreen)

    ' Optional but recommended settings for automation (ignore errors if properties don't exist)
    On Error Resume Next
    objTerminal.DisableKeystrokeProductivity = True ' Disable features that might interfere with scripting input
    If Err.Number <> 0 Then Debug.Print "Connect_V1: Info - Error setting DisableKeystrokeProductivity: " & Err.Description: Err.Clear
    objTerminal.DisableScreenHistory = True ' Disable screen history if not needed
    If Err.Number <> 0 Then Debug.Print "Connect_V1: Info - Error setting DisableScreenHistory: " & Err.Description: Err.Clear
    On Error GoTo ConnectErrorHandler_V1 ' Restore error handling

    ConnectToReflection_V1 = True ' Connection successful
    Debug.Print "Connect_V1: All core Reflection objects set successfully."
    Exit Function ' Exit function indicating success

ConnectErrorHandler_V1:
    ' Generic error handler for the connection function
    Debug.Print "Connect_V1: Error (captured) - " & Err.Number & ": " & Err.Description
    ConnectToReflection_V1 = False ' Ensure function returns False on any error
    ' A specific error message box might be added here if not handled by specific checks above
    Exit Function ' Exit function on error
End Function


' Releases the Reflection COM objects to free up resources.
Private Sub CleanUpReflectionObjects_V1()
    On Error Resume Next ' Ignore errors during cleanup

    Set objScreen = Nothing
    Set objTerminal = Nothing
    Set objView = Nothing
    Set objFrame = Nothing
    Set objReflectionApp = Nothing

    On Error GoTo 0 ' Reset error handling
    Debug.Print SCRIPT_TITLE & ": Reflection objects released."
End Sub

' --- Screen Interaction Helpers (Version 1 - Manual Wait) ---

' Waits for the host to be ready (OIA XStatus=0) using a manual loop with App.Wait and DoEvents.
' Also checks for and handles the Security Reminder screen within the loop.
Private Sub WaitUntilReady_V1(Optional ByVal timeoutMilliseconds As Long = 10000)
    If objScreen Is Nothing Or objReflectionApp Is Nothing Then
        Debug.Print "WaitUntilReady_V1: objScreen or objReflectionApp is Nothing. Cannot wait."
        Exit Sub
    End If

    Dim startTime As Date: startTime = Now
    Dim timeoutTime As Date: timeoutTime = DateAdd("s", timeoutMilliseconds / 1000, startTime) ' Calculate timeout time

    ' Debug.Print "WaitUntilReady_V1: Waiting for host ready (XStatus=0) or timeout (" & timeoutMilliseconds & "ms)... Current XStatus: " & objScreen.OIA.XStatus

    ' Loop until host is ready or timeout
    Do While objScreen.OIA.XStatus <> 0 And Now < timeoutTime

        ' ** Check for Security Reminder *during* the wait **
        If CheckForAndHandleSecurityReminder_V1() Then
            ' Debug.Print "WaitUntilReady_V1: Security Reminder handled. Continuing wait loop."
            ' After handling, the screen likely refreshed, OIA might be busy again.
            ' The loop condition (objScreen.OIA.XStatus <> 0) will re-evaluate,
            ' and we'll continue waiting for the host to settle on the next screen.
        End If

        ' Wait for a short period using App.Wait and allow other events to process
        objReflectionApp.Wait 50 ' Wait 50ms using Reflection's built-in wait
        DoEvents ' Allow other events (like screen updates) to process

        ' Optional: Debug print progress periodically if needed
        ' If DateDiff("s", startTime, Now) Mod 2 = 0 Then ' Print every 2 seconds
        '    Debug.Print "WaitUntilReady_V1: Waiting... Elapsed: " & DateDiff("s", startTime, Now) & "s. XStatus: " & objScreen.OIA.XStatus
        ' End If

    Loop

    ' Check if loop exited due to timeout
    If Now >= timeoutTime And objScreen.OIA.XStatus <> 0 Then
        Debug.Print "WaitUntilReady_V1: Timeout occurred (" & timeoutMilliseconds & "ms) waiting for XStatus=0. Last XStatus: " & objScreen.OIA.XStatus
        ' Optional: Add a more prominent warning or error here
        ' MsgBox "Timeout waiting for host readiness.", vbExclamation, SCRIPT_TITLE
    Else
        ' Debug.Print "WaitUntilReady_V1: OIA XStatus is 0."
    End If


    ' ** Check for Security Reminder *after* OIA is ready (XStatus is 0) **
    ' Handles the case where the reminder pops up exactly when the previous command finishes.
    ' Debug.Print "WaitUntilReady_V1: Checking for Security Reminder after OIA is 0..."
    CheckForAndHandleSecurityReminder_V1 ' Call Sub without parentheses

    ' Add a small final settle time after OIA is ready and Security handled
    ' This allows screen contents to finish drawing / stabilizing.
    objReflectionApp.Wait 200 ' Final settle wait

    ' Debug.Print "WaitUntilReady_V1: Host is ready (XStatus=" & objScreen.OIA.XStatus & " and settled)."
End Sub

' Checks for the Security Reminder screen and handles it by sending 'Y' and Transmit.
' This helper is designed to be called from within WaitUntilReady_V1's loop or after it.
' It does NOT recursively call WaitUntilReady_V1.
' Returns True if the reminder was detected and handled, False otherwise.
Private Function CheckForAndHandleSecurityReminder_V1() As Boolean
    CheckForAndHandleSecurityReminder_V1 = False ' Assume reminder is not present initially
    If objScreen Is Nothing Or objReflectionApp Is Nothing Then
        ' Debug.Print "CheckForAndHandleSecurityReminder_V1: objScreen or objReflectionApp is Nothing."
        Exit Function
    End If

    ' Check for the SECURITY REMINDER screen title at its known location (R1, C29, L20)
    If ScreenContainsText_V1(SCREEN_SECURITY_REMINDER, SECURITY_REMINDER_ROW, SECURITY_REMINDER_COL, SECURITY_REMINDER_LEN, 50) Then
        ' Debug.Print "CheckForAndHandleSecurityReminder_V1: Detected Security Reminder."

        ' Send 'Y' to the input field (R22, C11 - based on original code)
        objScreen.PutText2 "Y", SECURITY_REMINDER_INPUT_ROW, SECURITY_REMINDER_INPUT_COL
        ' Debug.Print "CheckForAndHandleSecurityReminder_V1: Sent 'Y' to R" & SECURITY_REMINDER_INPUT_ROW & "C" & SECURITY_REMINDER_INPUT_COL & "."

        ' Send Transmit key
        objScreen.SendControlKey ControlKeyCode_Transmit
        ' Debug.Print "CheckForAndHandleSecurityReminder_V1: Sent Transmit key."

        CheckForAndHandleSecurityReminder_V1 = True ' Indicate that the reminder was handled

        ' After sending Transmit, the OIA XStatus will become busy again.
        ' The outer WaitUntilReady_V1 (or the code after it) will handle waiting for the next state.
        ' No further waiting needed *within* this function.
    End If
     ' Debug.Print "CheckForAndHandleSecurityReminder_V1: Detection check finished. Handled: " & CheckForAndHandleSecurityReminder_V1
End Function

' Helper function to check for text at specific coordinates on the screen.
' Provides a minimal settle time before checking. Designed for checks inside wait loops.
' Returns True if text is found, False otherwise.
Private Function ScreenContainsText_V1(expectedText As String, rowNum As Long, colNum As Long, Optional ByVal length As Long = 0, Optional minSettleTimeMs As Long = 50) As Boolean
    If objScreen Is Nothing Or objReflectionApp Is Nothing Then ScreenContainsText_V1 = False: Exit Function

    ' Wait briefly for potential screen updates to start settling, but not a full Wait
    objReflectionApp.Wait minSettleTimeMs ' Use App.Wait for minimal settle

    ' If length is not specified, use the length of the expected text
    If length = 0 Then length = Len(expectedText)

    Dim actualText As String: actualText = ""
    On Error Resume Next ' GetText might error if coords are invalid
    actualText = Trim(objScreen.GetText(rowNum, colNum, length))
    On Error GoTo 0

    ' Compare expected text (case-insensitive)
    ScreenContainsText_V1 = (UCase(actualText) = UCase(expectedText))

    ' Optional: Debug print only if it matches, to reduce noise
    ' If ScreenContainsText_V1 Then Debug.Print "ScreenContainsText_V1: Found '" & expectedText & "' at R" & rowNum & "C" & colNum
End Function


' Sends data to a specific field on the screen and automatically sends Transmit.
' Uses WaitUntilReady_V1 internally before and after sending input.
Private Sub SendText_V1(data As String, rowNum As Long, colNum As Long)
    If objScreen Is Nothing Then
        Debug.Print "SendText_V1: objScreen is Nothing. Cannot send text."
        Exit Sub
    End If

    ' Debug.Print "SendText_V1: Waiting for host before sending text."
    Call WaitUntilReady_V1() ' Wait for the screen to be ready before attempting input
    ' Debug.Print "SendText_V1: Host ready. Sending text."


    ' Debug.Print "SendText_V1: Putting data '" & data & "' at R" & rowNum & "C" & colNum & "."
    objScreen.PutText2 data, rowNum, colNum ' Put the text onto the screen

    ' Debug.Print "SendText_V1: Sending Transmit key."
    objScreen.SendControlKey ControlKeyCode_Transmit ' Send the Enter key (Transmit)

    ' Debug.Print "SendText_V1: Waiting for host after sending text."
    Call WaitUntilReady_V1(5000) ' Wait for the host to process the input and update the screen (use a slightly longer wait after Transmit)
    ' Debug.Print "SendText_V1: Wait after sending text complete."
End Sub

' --- Unused/Removed Helper Functions from previous versions ---
' The following functions from previous versions are removed for simplification
' as they are not required for this specific first step (Send TERM ALL).
' - NavigateToScreen_ManualWait / NavigateToScreen_RevisedV9 / NavigateToScreen_V9
' - VerifyScreen_ManualWait / VerifyScreen_RevisedV9 / VerifyScreen_V9
' - BackToMasterIndex_ManualWait
