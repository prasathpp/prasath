Option Explicit

' --- Reflection COM Object Declarations ---
' These variables will hold the references to the Reflection objects
' needed to control the host session.
Public RApp As Object          ' Represents the main Reflection Workspace application
Public RFrame As Object        ' Represents the main window frame containing views
Public RView As Object         ' Represents the specific session view/tab (e.g., the TN3270 session)
Public RTerminal As Object     ' Represents the terminal control within the view
Public RScreen As Object       ' Represents the interactive screen area of the terminal

' --- Constants ---
' Define the part of the session file name we will look for in the window title.
Private Const TARGET_SESSION_FILE_PART As String = "NTS Back Office - Prod.rd3x"
' Define the text and coordinates for the command line
Private Const COMMAND_LINE_ROW As Long = 21
Private Const COMMAND_LINE_COL As Long = 13
' Define the text and coordinates for the Security Reminder screen
Private Const SCREEN_SECURITY_REMINDER As String = "SECURITY REMINDER"
Private Const SECURITY_REMINDER_ROW As Long = 1
Private Const SECURITY_REMINDER_COL As Long = 29
Private Const SECURITY_REMINDER_LEN As Long = 20 ' Length of the text "SECURITY REMINDER"

' --- Script Title for MsgBoxes ---
Private Const SCRIPT_TITLE As String = "Interest Amendment Automation Step 1"

' --- Main Entry Sub for Step 1 ---
' This is the procedure you will run to perform the first step:
' Connect to Reflection and send "TERM ALL" on the command line.
Sub Main_Step1_SendTermAll()

    Debug.Print "--- Starting Main_Step1_SendTermAll ---"

    ' 1. Attempt to connect to the existing Reflection session
    If ConnectToReflection(TARGET_SESSION_FILE_PART) Then
        Debug.Print "Main_Step1: Successfully connected to Reflection session."

        ' 2. Send "TERM ALL" to the command line (R21, C13)
        ' The SendText function will handle waiting and sending the Transmit key.
        Debug.Print "Main_Step1: Sending 'TERM ALL' to command line..."
        SendText "TERM ALL", COMMAND_LINE_ROW, COMMAND_LINE_COL

        Debug.Print "Main_Step1: 'TERM ALL' sent. First step complete."

    Else
        ' Connection failed - an error message was already shown by ConnectToReflection
        Debug.Print "Main_Step1: Failed to connect to Reflection session. Aborting."
    End If

    ' 3. Clean up the Reflection objects regardless of success
    CleanUpReflectionObjects

    Debug.Print "--- Finished Main_Step1_SendTermAll ---"

End Sub

' --- Connection Logic ---
' Connects to an existing Reflection Workspace and finds the specified session
' by searching for a partial match in the window titles.
Private Function ConnectToReflection(ByVal sessionTitlePart As String) As Boolean
    On Error GoTo ErrorHandler
    ConnectToReflection = False ' Assume failure initially

    Debug.Print "ConnectToReflection: Attempting GetObject(""Reflection Workspace"")..."
    On Error Resume Next ' Allow GetObject to fail if Reflection is not running
    Set RApp = GetObject("Reflection Workspace")
    If Err.Number <> 0 Or RApp Is Nothing Then
        Err.Clear
        Debug.Print "ConnectToReflection: GetObject(""Reflection Workspace"") FAILED."
        MsgBox "Could not connect to Reflection Workspace." & vbCrLf & _
               "Please ensure Reflection is running and that 'Enable Reflection Automation' is checked.", vbCritical, SCRIPT_TITLE
        Exit Function
    End If
    Debug.Print "ConnectToReflection: RApp obtained. TypeName: " & TypeName(RApp)
    On Error GoTo ErrorHandler ' Restore main error handler

    Set RFrame = RApp.GetObject("Frame")
    If RFrame Is Nothing Then
         Debug.Print "ConnectToReflection: RFrame is Nothing."
         MsgBox "Could not get the Reflection Frame object.", vbCritical, SCRIPT_TITLE
         Exit Function
    End If
    Debug.Print "ConnectToReflection: RFrame obtained. TypeName: " & TypeName(RFrame)

    ' Ensure the frame is visible and brought to front (optional but helpful)
    If Not RFrame.Visible Then RFrame.Visible = True
    RFrame.Activate ' Brings the main Reflection Workspace window to front

    Debug.Print "ConnectToReflection: Searching for view matching """ & sessionTitlePart & """ in title..."
    Dim viewFound As Boolean: viewFound = False
    Dim view As Object
    ' Iterate through all open session views in the frame
    For Each view In RFrame.Views
        ' Check if the view's title text contains the specified part (case-insensitive)
        If InStr(1, view.TitleText, sessionTitlePart, vbTextCompare) > 0 Then
             Set RView = view ' Found the target view
             viewFound = True
             Exit For ' Exit the loop
        End If
    Next view

    If Not viewFound Or RView Is Nothing Then
        Debug.Print "ConnectToReflection: Could not find view matching '" & sessionTitlePart & "'."
        MsgBox "Could not find a Reflection session with '" & sessionTitlePart & "' in its title." & vbCrLf & _
               "Please ensure the correct session file is open in Reflection.", vbCritical, SCRIPT_TITLE
        Exit Function ' Exit function if the view was not found
    End If
    Debug.Print "ConnectToReflection: RView obtained. Title: '" & RView.TitleText & "'. TypeName: " & TypeName(RView)

    ' Try activating the found view to bring its tab/window to focus (ignore error if it fails)
    On Error Resume Next
    RView.Activate
    If Err.Number <> 0 Then Debug.Print "ConnectToReflection: Info - Error RView.Activate: " & Err.Description: Err.Clear
    On Error GoTo ErrorHandler ' Restore main error handler


    Set RTerminal = RView.Control
    If RTerminal Is Nothing Then
        Debug.Print "ConnectToReflection: RTerminal is Nothing."
        MsgBox "Could not get the Reflection Terminal control.", vbCritical, SCRIPT_TITLE
        Exit Function
    End If
    Debug.Print "ConnectToReflection: RTerminal obtained. TypeName: " & TypeName(RTerminal)

    Set RScreen = RTerminal.Screen
    If RScreen Is Nothing Then
        Debug.Print "ConnectToReflection: RScreen is Nothing."
        MsgBox "Could not get the Reflection Screen object.", vbCritical, SCRIPT_TITLE
        Exit Function
    End If
    Debug.Print "ConnectToReflection: RScreen obtained. TypeName: " & TypeName(RScreen)

    ' Optional but recommended settings for automation
    On Error Resume Next
    RTerminal.DisableKeystrokeProductivity = True ' Disable features that might interfere with scripting input
    If Err.Number <> 0 Then Debug.Print "ConnectToReflection: Info - Error DisableKeystrokeProductivity: " & Err.Description: Err.Clear
    RTerminal.DisableScreenHistory = True ' Disable screen history
    If Err.Number <> 0 Then Debug.Print "ConnectToReflection: Info - Error DisableScreenHistory: " & Err.Description: Err.Clear
    On Error GoTo ErrorHandler

    ConnectToReflection = True ' Connection successful
    Debug.Print "ConnectToReflection: All core Reflection objects set successfully."
    Exit Function

ErrorHandler:
    Debug.Print "ConnectToReflection Error " & Err.Number & ": " & Err.Description
    ConnectToReflection = False ' Ensure function returns False on error
End Function

' Releases the Reflection COM objects to free up resources.
Private Sub CleanUpReflectionObjects()
    On Error Resume Next ' Ignore errors during cleanup

    Set RScreen = Nothing
    Set RTerminal = Nothing
    Set RView = Nothing
    Set RFrame = Nothing
    Set RApp = Nothing

    On Error GoTo 0 ' Reset error handling
    Debug.Print "Reflection objects released."
End Sub

' --- Screen Interaction Helpers ---

' Waits for the host OIA area to indicate readiness (XStatus = 0).
' Includes a check for the Security Reminder screen within the wait loop.
Private Sub WaitUntilReady(Optional timeoutMs As Long = 10000)
    If RScreen Is Nothing Then Exit Sub
    Dim startTime As Date: startTime = Now

    ' Wait for OIA XStatus to become 0 (indicating command processing is done or system is idle)
    Do While RScreen.OIA.XStatus <> 0
        ' Check for timeout
        If DateDiff("s", startTime, Now) * 1000 > timeoutMs Then
            Debug.Print "WaitUntilReady: Timeout waiting for XStatus=0."
            ' Optional: Add error handling or message box here for timeout
            Exit Do ' Exit loop on timeout
        End If

        ' Wait for a short period for the host to settle
        ' Using smaller increments as seen in your original code
        RScreen.WaitForHostSettle 50, 20: DoEvents ' Wait 50ms, check every 20ms, allow UI events

        ' ** Check for Security Reminder *during* the wait **
        ' This handles the case where the reminder pops up while we're waiting for the host.
        If CheckForAndHandleSecurityReminder() Then
             ' If reminder was handled, the screen likely changed or reset.
             ' We should ideally re-evaluate the main screen state after this,
             ' but for just waiting for readiness, we can continue the loop.
             ' CheckForAndHandleSecurityReminder calls WaitUntilReady itself, so recursion here is okay.
             ' Alternatively, structure WaitUntilReady to check *after* OIA is 0.
             ' Let's adjust: Move the security check to *after* OIA is 0, before returning.
             Exit Do ' Exit the OIA wait loop if Security Reminder was just handled
        End If

    Loop

    ' ** Check for Security Reminder *after* OIA is ready **
    ' This handles the case where the reminder pops up right as the OIA becomes ready.
    CheckForAndHandleSecurityReminder

    ' Add a small final settle time after OIA is ready and Security handled, as in original code
    RScreen.WaitForHostSettle 200, 1000 ' Wait 200ms for screen content to stabilize

End Sub

' Checks for the Security Reminder screen and handles it by sending 'Y' and Transmit.
' Returns True if handled, False otherwise.
Private Function CheckForAndHandleSecurityReminder() As Boolean
    CheckForAndHandleSecurityReminder = False
    If RScreen Is Nothing Then Exit Function

    ' Check for the SECURITY REMINDER screen title at its known location
    ' Use a very short wait here, as this is called *from* WaitUntilReady
    If ScreenContainsText(SCREEN_SECURITY_REMINDER, SECURITY_REMINDER_ROW, SECURITY_REMINDER_COL, SECURITY_REMINDER_LEN, 50) Then
        Debug.Print "CheckForAndHandleSecurityReminder: Detected Security Reminder. Sending 'Y'."
        ' Send 'Y' to the input field (adjust coords if different from original code's 22,11)
        RScreen.PutText2 "Y", 22, 11 ' Based on original code's Check_SecurityScreen
        ' Send Transmit key
        RScreen.SendControlKey ControlKeyCode_Transmit
        Debug.Print "CheckForAndHandleSecurityReminder: Sent 'Y' and Transmit."
        CheckForAndHandleSecurityReminder = True
        ' ** Important: Wait again after handling the reminder **
        ' The host needs time to process the 'Y' and move to the next screen.
        ' Recursively call WaitUntilReady to wait for the *next* screen to be ready.
        WaitUntilReady()
    End If
End Function

' Helper function to check for text without triggering full WaitUntilReady repeatedly if called inside it.
' Takes an optional minimal settle time.
Private Function ScreenContainsText(expectedText As String, rowNum As Long, colNum As Long, Optional ByVal length As Long = 0, Optional minSettleTimeMs As Long = 50) As Boolean
    If RScreen Is Nothing Then ScreenContainsText = False: Exit Function

    ' Wait briefly for potential screen updates to start, but not a full WaitUntilReady
    RScreen.WaitForHostSettle minSettleTimeMs, 1000 ' Short settle

    If length = 0 Then length = Len(expectedText)
    Dim actualText As String: actualText = Trim(RScreen.GetText(rowNum, colNum, length))

    ScreenContainsText = (UCase(actualText) = UCase(expectedText))
    ' Optional: Debug print only if it matches, to reduce noise
    ' If ScreenContainsText Then Debug.Print "ScreenContainsText: Found '" & expectedText & "' at R" & rowNum & "C" & colNum
End Function


' Sends data to a specific field on the screen and automatically sends Transmit.
' Uses WaitUntilReady internally.
Private Sub SendText(data As String, rowNum As Long, colNum As Long)
    If RScreen Is Nothing Then Exit Sub

    Call WaitUntilReady() ' Wait for the screen to be ready before input

    Debug.Print "SendText: Putting data '" & data & "' at R" & rowNum & "C" & colNum
    RScreen.PutText2 data, rowNum, colNum ' Put the text

    Debug.Print "SendText: Sending Transmit key."
    RScreen.SendControlKey ControlKeyCode_Transmit ' Send the Enter key (Transmit)

    Call WaitUntilReady() ' Wait for the host to process the input and update the screen
End Sub

' NOTE: SendKey helper (for F-keys etc.) is not strictly needed for JUST "TERM ALL" but is useful later.
' Let's add a basic one for completeness, similar to previous version.
Private Sub SendControlKey(keyCode As Long)
     If RScreen Is Nothing Then Exit Sub

     Call WaitUntilReady() ' Wait before sending the key

     Debug.Print "SendControlKey: Sending key code " & keyCode
     RScreen.SendControlKey keyCode ' Send the specified control key

     Call WaitUntilReady() ' Wait for the host to process the key
End Sub


' You would add more navigation steps as separate subs or a larger function here later.
' For now, Main_Step1_SendTermAll is our primary focus.
