Sub SplitDataIntoMultipleWorkbooks_Improved()
    Dim ws As Worksheet
    Dim wb As Workbook
    Dim headerRange As Range
    Dim totalRows As Long, rowsPerWorkbook As Long, extraRows As Long
    Dim startRow As Long, endRow As Long
    Dim splitCount As Long, numberOfSplits As Long
    Dim savePath As String
    Dim fileName As String
    Dim splitFileName As String
    Dim fDialog As FileDialog

    ' --- Performance & Environment Settings ---
    Dim originalScreenUpdating As Boolean
    Dim originalCalculation As XlCalculation
    Dim originalEnableEvents As Boolean
    Dim originalDisplayAlerts As Boolean

    ' Store original Excel settings
    originalScreenUpdating = Application.ScreenUpdating
    originalCalculation = Application.Calculation
    originalEnableEvents = Application.EnableEvents
    originalDisplayAlerts = Application.DisplayAlerts

    ' Apply performance settings
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.DisplayAlerts = False ' Attempt to suppress prompts, including overwrite and potentially sensitivity

    On Error GoTo ErrorHandler

    ' Set the active worksheet (current active sheet in the active workbook)
    Set ws = ActiveSheet

    ' Get the total number of rows of data, assuming the first row contains headers
    totalRows = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row

    ' Check if there's enough data to split (at least one row of data plus header)
    If totalRows <= 1 Then
        MsgBox "Not enough data to split. Please ensure your data has multiple rows.", vbExclamation
        GoTo CleanExit ' Use GoTo for cleanup
    End If

    ' Prompt user to input the number of splits
    Dim splitsInput As Variant
    splitsInput = InputBox("Enter the number of parts you want to split the data into:", "Split Data")

    ' Validate the user input for number of splits
    If Not IsNumeric(splitsInput) Then
        MsgBox "Invalid input. Please enter a positive number greater than zero.", vbExclamation
        GoTo CleanExit
    End If
    
    numberOfSplits = CLng(splitsInput) ' Convert to Long
    
    If numberOfSplits <= 0 Then
        MsgBox "Invalid input. Number of splits must be greater than zero.", vbExclamation
        GoTo CleanExit
    End If


    ' Define the header range (assuming headers are in the first row)
    Set headerRange = ws.Rows(1)

    ' Calculate rows per workbook and extra rows if any (excluding header)
    rowsPerWorkbook = (totalRows - 1) \ numberOfSplits ' Determine rows per workbook
    extraRows = (totalRows - 1) Mod numberOfSplits      ' Determine leftover rows

    ' Check if rowsPerWorkbook is zero, which would cause issues
    If rowsPerWorkbook = 0 And (totalRows - 1) > 0 Then ' Ensure there's data but not enough for all splits
        MsgBox "Not enough rows to split across " & numberOfSplits & " workbooks with at least one data row each. " & _
               "Each split part must contain at least one data row. Try fewer splits or add more data.", vbExclamation
        GoTo CleanExit
    ElseIf (totalRows - 1) = 0 Then ' No data rows at all
         MsgBox "No data rows found to split (excluding header).", vbExclamation
        GoTo CleanExit
    End If


    ' --- Get Save Path from User ---
    Set fDialog = Application.FileDialog(msoFileDialogFolderPicker)
    fDialog.Title = "Select a Folder to Save the Split Files"
    If fDialog.Show = True Then
        savePath = fDialog.SelectedItems(1)
        ' Ensure path ends with a path separator
        If Right(savePath, 1) <> Application.PathSeparator Then
            savePath = savePath & Application.PathSeparator
        End If
    Else
        MsgBox "No folder selected. Operation cancelled.", vbInformation
        GoTo CleanExit ' Use GoTo for cleanup
    End If
    ' No need to check if Dir(savePath, vbDirectory) = "" because FileDialog ensures it exists

    ' Get the base file name of the active workbook (without extension)
    If InStrRev(ActiveWorkbook.Name, ".") > 0 Then
        fileName = Left(ActiveWorkbook.Name, InStrRev(ActiveWorkbook.Name, ".") - 1)
    Else
        fileName = ActiveWorkbook.Name ' Workbook might not have an extension (e.g., new unsaved)
    End If


    ' If rowsPerWorkbook is valid, proceed with the split
    startRow = 2 ' Data starts from row 2 (excluding the header)

    ' Split data into the specified number of workbooks
    For splitCount = 1 To numberOfSplits
        If startRow <= totalRows Then
            ' Create a new workbook for each split
            Set wb = Workbooks.Add

            ' Copy header to the new workbook
            headerRange.Copy Destination:=wb.Sheets(1).Rows(1)
            
            ' Determine the end row for this split
            Dim currentRowsForThisSplit As Long
            currentRowsForThisSplit = rowsPerWorkbook
            If extraRows > 0 Then
                currentRowsForThisSplit = currentRowsForThisSplit + 1
                extraRows = extraRows - 1 ' Reduce the extra row count
            End If
            
            ' If no rows for this split (can happen if total data rows < numberOfSplits)
            If currentRowsForThisSplit = 0 Then
                ' This case should ideally be caught by the earlier check for rowsPerWorkbook = 0
                ' but as a failsafe if logic allows it to reach here with 0 rows for a part
                wb.Close SaveChanges:=False ' Close the empty workbook
                Set wb = Nothing
                GoTo NextSplitIteration ' Skip to next iteration
            End If

            endRow = startRow + currentRowsForThisSplit - 1

            ' Ensure we don't exceed total rows
            If endRow > totalRows Then endRow = totalRows
            
            ' If, after adjustments, startRow is beyond endRow (e.g. no data left for this split)
            If startRow > endRow Then
                wb.Close SaveChanges:=False ' Close the empty workbook
                Set wb = Nothing
                GoTo NextSplitIteration ' Skip to next iteration
            End If


            ' Copy data to the new workbook
            ws.Rows(startRow & ":" & endRow).Copy Destination:=wb.Sheets(1).Rows(2)

            ' Construct the file name for each split workbook
            splitFileName = savePath & fileName & "_part" & splitCount & ".xlsx"

            ' Save the new workbook using the specified path and filename format
            ' *** This is where the Sensitivity Label prompt might appear ***
            wb.SaveAs fileName:=splitFileName, FileFormat:=xlOpenXMLWorkbook ' Explicitly specify modern format
            wb.Close SaveChanges:=False ' Already saved

            ' Move to the next starting row
            startRow = endRow + 1
            
            ' Reopen the saved workbook so all split files will be visible
            ' (This line was in the original and not requested to be removed)
            ' Note: Reopening might also trigger sensitivity label prompts if policies apply on open.
            If Dir(splitFileName) <> "" Then ' Check if file was actually saved before trying to open
                 Workbooks.Open fileName:=splitFileName
            End If
        End If
NextSplitIteration:
    Next splitCount

    MsgBox "Data has been successfully split into " & numberOfSplits & " workbooks, saved" & _
           IIf(Application.DisplayAlerts = False, " (and attempts were made to open them)", "") & _
           " in the folder: " & vbCrLf & savePath, vbInformation

CleanExit:
    ' Restore original Excel settings
    Application.DisplayAlerts = originalDisplayAlerts
    Application.EnableEvents = originalEnableEvents
    Application.Calculation = originalCalculation
    Application.ScreenUpdating = originalScreenUpdating

    ' Clean up object variables
    Set ws = Nothing
    Set wb = Nothing
    Set headerRange = Nothing
    Set fDialog = Nothing
    Exit Sub

ErrorHandler:
    MsgBox "An error occurred: " & Err.Description & vbCrLf & _
           "Macro will now attempt to restore Excel settings and exit.", vbCritical, "Error"
    Resume CleanExit ' Go to cleanup and exit

End Sub
